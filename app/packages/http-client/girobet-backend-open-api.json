{
  "openapi": "3.1.0",
  "info": {
    "title": "Girobet Casino API",
    "description": "# Introduction\n\nThe API to the **GiroBet Casino** system. This API aims to be *highly scalable* and to be *independent of any frontend implementations*.\nAuthentication is done only via **HTTP cookies**, which are set by the server after a successful login.\nThe API is *stateless* and does not store any session data on the server, other than some session metadata such as the useragent and the IP address.\n\n### Endpoints\n\n- API can be accessed [here](http://[::1]:3050).\n- JSON schema can be found [here](http://[::1]:3050/docs/private/api.json).\n\n\n## Common terms\n\nBelow is a list of common terms used in the API documentation and the online casino industry.\n\n<details>\n<summary>Legend</summary>\n\nPlayer Metrics\n\n- **FTD** - First Time Depositor: A player who has made their first real money deposit\n- **NGR** - Net Gaming Revenue: Total bets minus total wins and bonuses\n- **GGR** - Gross Gaming Revenue: Total bets minus total wins (before bonus deductions)\n- **LTV** - Lifetime Value: The predicted or actual total revenue generated by a player\n- **RFM** - Recency, Frequency, Monetary: Player scoring model based on last activity, play frequency, and spending\n- **CPA** - Cost Per Acquisition: Marketing cost to acquire one new player\n- **KYC** - Know Your Customer: Player verification process required by regulators\n\n**Game Mechanics**\n\n- **RNG** - Random Number Generator: System that ensures game outcome randomness\n- **RTP** - Return To Player: Theoretical percentage of wagers returned to players over time\n- **GS** - Game Session: A single instance of player gameplay\n- **MAT** - Maximum Allowable Turnover: Betting limit within a specified timeframe\n- **MG** - Minimum Guarantee: Minimum amount a game must pay out\n- **HP** - Hit Pattern: Frequency of winning combinations in slots\n- **VP** - Volatility Profile: Risk/reward distribution pattern of a game\n\n**Technical Integration**\n\n- **API** - Application Programming Interface: Interface for software communication\n- **JWT** - JSON Web Token: Standard method for secure data transmission\n- **WS** - WebSocket: Protocol for real-time communication\n- **SSE** - Server-Sent Events: Server push technology for real-time updates\n- **P2P** - Peer-to-Peer: Direct communication between clients\n- **SDK** - Software Development Kit: Tools for integration\n- **SRS** - Session Recovery System: System to handle interrupted game sessions\n\n**Compliance and Security**\n\n- **AML** - Anti-Money Laundering: Regulatory framework to prevent financial crimes\n- **PEP** - Politically Exposed Person: Individual who requires enhanced due diligence\n- **RG** - Responsible Gaming: Tools and policies to promote safe gambling\n- **SCA** - Strong Customer Authentication: Enhanced security verification\n- **VIP** - Very Important Player: High-value player requiring additional monitoring\n- **GF** - Game Fairness: Certification of game randomness and fairness\n- **RT** - Reality Test: Periodic player notification of time spent gaming\n\n**Financial**\n\n- **CB** - Chargeback: Disputed or reversed transaction\n- **ROI** - Return on Investment: Profit relative to investment\n- **MBG** - Minimum Bet Guarantee: Lowest acceptable bet amount\n- **RR** - Revenue Rate: Speed of revenue generation\n- **ACH** - Automated Clearing House: Electronic funds transfer system\n- **WR** - Wagering Requirements: Playthrough needed to withdraw bonuses\n- **CR** - Conversion Rate: Percentage of visitors who become depositors\n\n**Market and Analytics**\n\n- **MAU** - Monthly Active Users: Unique players in a month\n- **DAU** - Daily Active Users: Unique players in a day\n- **CCR** - Customer Conversion Rate: Registration to deposit ratio\n- **SEO** - Search Engine Optimization: Techniques to improve visibility\n- **B2B** - Business to Business: Casino software provider services\n- **B2C** - Business to Consumer: Direct casino to player services\n- **TAM** - Total Addressable Market: Potential market size\n\n**System Status**\n\n- **TTR** - Time To Respond: API response latency\n- **SLA** - Service Level Agreement: Guaranteed service parameters\n- **TPS** - Transactions Per Second: System throughput measure\n- **MTD** - Month To Date: Current month's statistics\n- **YTD** - Year To Date: Current year's statistics\n- **QoS** - Quality of Service: Service performance metrics\n- **UPT** - Uptime: System availability percentage\n\n</details>\n\n\n## Jurisdiction Checking System\n\nOur online casino API implements a *sophisticated jurisdiction checking system* to ensure compliance with various licensing requirements. This document outlines how the system works and what frontend developers need to know when interacting with the API.\n\n### Key Concepts\n\n- **Sites**: A Site represents a *logical grouping* of one or more domains.\n- **Licenses**: Licenses are mapped to Sites via a *many-to-many relationship*.\n- **Jurisdiction Enforcement**: The API enforces jurisdictions based on the *incoming request's headers* and *user account information*.\n\n### Header Requirements\n\nThe API relies on **two crucial headers** to enforce jurisdictions:\n\n1. `CF-IPCountry`: Provided by Cloudflare, indicating the *country of origin* for the request.\n2. `Host`: The *domain name* of the requested site.\n\n**Important**: The `Host` header is interchangeable with the `Forwarded` or `X-Forwarded-Host` headers. The API will check for these headers in the following order of preference: `Forwarded`, `X-Forwarded-Host`, `Host`. Use whichever is most appropriate for your setup.\n\n#### Important Notes\n\n- In production, the `CF-IPCountry` header is *typically always set*, as we use Cloudflare to proxy all requests.\n- If either the country header (`CF-IPCountry`) or a host header (`Forwarded`, `X-Forwarded-Host`, or `Host`) is missing, the API will *not force a jurisdiction*. Most requests will still succeed, except for certain operations like signup that require jurisdiction information.\n\n### Jurisdiction Enforcement Flow\n\n#### For Anonymous Users\n\n1. The API checks for the presence of both `CF-IPCountry` and a host header (`Forwarded`, `X-Forwarded-Host`, or `Host`).\n2. If both headers are present, the API determines the appropriate jurisdiction based on the Site and License mappings.\n3. If either header is missing, no jurisdiction is enforced, but certain operations may be restricted.\n\n#### For Logged-in Users\n\nFor logged-in users, the process is more complex to account for potential VPN usage:\n\n1. The API performs the same checks as for anonymous users (CF-IPCountry and host headers).\n2. Additionally, the API retrieves the jurisdiction associated with the user's account.\n3. The system then performs the following checks:\n   1. Verifies that the jurisdiction indicated by the CF-IPCountry header is covered by at least one license, that has a mapping to a Site that also covers the host.\n   2. Checks if the user's account jurisdiction is also covered by at least one license that fulfills step *3.1*.\n4. Possible scenarios:\n   - If both jurisdictions (CF-IPCountry and user's account) are covered by the same license, the request is allowed.\n   - If the CF-IPCountry jurisdiction is a blocked jurisdiction for the relevant license(s), the request is denied.\n   - If the user's account jurisdiction is not covered by the same license as the CF-IPCountry jurisdiction, the request is denied.\n\nThis approach allows for *legitimate VPN usage* while maintaining compliance with licensing requirements.\n\n### For Frontend Developers\n\n#### Standard API Requests\n\nEnsure that your requests to the API include either the `Host`, `Forwarded`, or `X-Forwarded-Host` header. The `CF-IPCountry` header will be automatically set by Cloudflare in production environments.\n\n#### Server-Side Rendering (SSR) Approach\n\nIf you're using an SSR approach:\n\n1. Your server will receive the original host information from the client request.\n2. When making internal requests from your SSR server to our API, you must proxy this host information using one of the accepted headers.\n3. You should also forward the `CF-IPCountry` header, as we're not interested in the SSR server's country, but the client's country of origin.\n\nYou have **several options** for forwarding the host information:\n\n1. Proxy the original `Host` header\n2. Use the `Forwarded` header\n3. Use the `X-Forwarded-Host` header\n\nExample using the `Host` and `CF-IPCountry` headers:\n\n```javascript\n// In your SSR server\napp.get('/some-route', async (req, res) => {\n  const apiResponse = await fetch('https://api.ourcasino.com/endpoint', {\n    headers: {\n      'Host': req.headers.host, // Proxy the original Host header\n      'CF-IPCountry': req.headers['cf-ipcountry'] || 'XX', // Proxy CF-IPCountry or use a default value\n    },\n  });\n  // Process the response...\n});\n```\n\nExample using the `Forwarded` header and `CF-IPCountry`:\n\n```javascript\napp.get('/some-route', async (req, res) => {\n  const apiResponse = await fetch('https://api.ourcasino.com/endpoint', {\n    headers: {\n      'Forwarded': `host=${req.headers.host}`, // Use the Forwarded header\n      'CF-IPCountry': req.headers['cf-ipcountry'] || 'XX', // Proxy CF-IPCountry or use a default value\n    },\n  });\n  // Process the response...\n});\n```\n\nExample using the `X-Forwarded-Host` header and `CF-IPCountry`:\n\n```javascript\napp.get('/some-route', async (req, res) => {\n  const apiResponse = await fetch('https://api.ourcasino.com/endpoint', {\n    headers: {\n      'X-Forwarded-Host': req.headers.host, // Use the X-Forwarded-Host header\n      'CF-IPCountry': req.headers['cf-ipcountry'] || 'XX', // Proxy CF-IPCountry or use a default value\n    },\n  });\n  // Process the response...\n});\n```\n\nChoose the method that best fits your infrastructure and security requirements. The `Forwarded` header is the *standardized version*, while `X-Forwarded-Host` is a *commonly used non-standard header*. The original `Host` header is the *most straightforward* but may not always be suitable in complex setups.\n\nRemember to handle the `CF-IPCountry` header appropriately in your development environment. You may need to set it manually or use a default value (like 'XX' in the examples above) to simulate different jurisdictions during testing.\n\n### Error Handling\n\nFrontend developers should be prepared to handle the following scenarios:\n\n1. Jurisdiction mismatch errors for logged-in users (e.g., when VPN jurisdiction doesn't match account jurisdiction).\n2. Blocked jurisdiction errors.\n3. Missing header errors (in development environments).\n\nThe API will return appropriate error codes and messages for these scenarios, which should be displayed to the user or used to redirect them as needed.\n\n### Testing and Development\n\nFor testing and development purposes, you may need to manually set both the `CF-IPCountry` and the appropriate host header to simulate different jurisdictions and domains. In production, the `CF-IPCountry` header will be reliably set by Cloudflare, while the host information will come from the client's request.\n\n**Remember** that the jurisdiction checking system is *critical* for maintaining compliance with various regulatory requirements. Always ensure that your frontend implementation correctly handles jurisdiction-based restrictions and redirects as specified by the API responses.\n\n\n## Errors\n\nAPI error responses generally follow this structure:\n\n```json\n{\n    \"code\": \"ERR_CODE\",\n    \"message\": \"Error message\",\n    \"metadata\": {\n      \"key\": \"value\"\n    }\n}\n```\n\nIn the table below, you'll find an exhaustive list of error codes and their descriptions.\nThese codes are used across the API to indicate specific error conditions.\nYou should handle these errors in your frontend implementation to provide a good user experience.\n\n> Note that in the OpenAPI schema, errors don't contain the `message` field, as they're not meant to be handled by the client, and should solely be used for debugging purposes.\n\n<br>\n\n\n\n---\n\n### Wallet was not found\n\n\n`WALLET_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The wallet ID provided doesn't exist\n\n- The wallet belongs to a different user\n\n- The wallet has been deleted or deactivated\n\n**Resolution:** Double-check the wallet ID and ensure you're using the correct currency.\n\n</details>\n\n\n---\n\n### Pending payment flow\n\n\n`WALLET_PENDING_FLOW`\n\n<details>\n<summary>Details</summary>\nThis error occurs when attempting to initiate a new payment flow while an existing one is still in progress. The existing flow must be completed by either:\n\n- Approving - Rejecting - Failing - Completing\n\n**Resolution:** Wait for the current flow to be processed or cancel it if possible.\n\n</details>\n\n\n---\n\n### Wallet Is Missing a Payment Method\n\n\n`WALLET_MISSING_PAYMENT_METHOD`\n\n<details>\n<summary>Details</summary>\nThis typically occurs when:\n\n- It's a new wallet that hasn't been used for deposits yet - The previously attached payment method has been removed or invalidated\n\n**Note:** A payment method is usually attached to the wallet on the first successful deposit. Subsequent deposits and withdrawals can only be made using the same payment method.\n\n**Resolution:** Make an initial deposit to link a payment method to the wallet.\n\n</details>\n\n\n---\n\n### Wallet Has Insufficient Funds\n\n\n`WALLET_INSUFFICIENT_FUNDS`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- Attempting to withdraw more than the available balance - Trying to place a bet that exceeds the wallet balance\n\n**Resolution:** Deposit additional funds into the wallet before attempting the operation again.\n\n</details>\n\n\n---\n\n### Wallet Has No Deposit\n\n\n`WALLET_MISSING_DEPOSIT`\n\n<details>\n<summary>Details</summary>\nThis error occurs when trying to withdraw or bet with a wallet that has never received any funds.\n\n**Resolution:** Make an initial deposit into the wallet before attempting withdrawals or bets.\n\n</details>\n\n\n---\n\n### Wallet Has Insufficient Wagers\n\n\n`WALLET_INSUFFICIENT_WAGERS`\n\n<details>\n<summary>Details</summary>\nThis error is typically thrown when:\n\n- The user tries to withdraw more money than allowed by the anti-money laundering system - The wallet hasn't met the minimum wagering requirements for withdrawals\n\n**Resolution:** Place more wagers or bets before attempting to withdraw funds.\n\n</details>\n\n\n---\n\n### Wallet Payment Cooldown\n\n\n`WALLET_PAYMENT_COOLDOWN`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- A user attempts to make multiple withdrawals within a short time frame - The cooldown period (usually 24 hours) hasn't elapsed since the last withdrawal\n\n**Purpose:** This ensures that users don't abuse the system by making multiple withdrawals in a short period to circumvent withdrawal limits or the anti-money laundering system.\n\n**Resolution:** Wait for the specified time before attempting another withdrawal.\n\n</details>\n\n\n---\n\n### Payment Method Not Allowed\n\n\n`PAYMENT_METHOD_NOT_ALLOWED`\n\n<details>\n<summary>Details</summary>\nThis can happen when:\n\n- The user tries to trigger a payment outside of the attached payment method - The user tries to use a payment method that is not allowed in their jurisdiction\n\n**Resolution:** Choose a different, allowed payment method for the operation.\n\n</details>\n\n\n---\n\n### Payment Amount Outside Limits\n\n\n`PAYMENT_AMOUNT_OUTSIDE_LIMITS`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The payment amount is below the minimum allowed - The payment amount is above the maximum allowed\n\n**Resolution:** Adjust the payment amount to be within the specified limits.\n\n</details>\n\n\n---\n\n### Payment Amount Exceeds Timeframe Limits\n\n\n`PAYMENT_AMOUNT_EXCEEDS_TIMEFRAME_LIMITS`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- A user attempts to make payments exceeding a certain amount in a specific timeframe - The limit may exist on a wallet or global currency level\n\n**Note:** A user can have multiple such timeframe limits, all of which are checked before a payment is allowed.\n\n**Resolution:** Wait for the timeframe to reset or make smaller payments spread over time.\n\n</details>\n\n\n---\n\n### Payment Amount Out of Bounds\n\n\n`PAYMENT_AMOUNT_OUT_OF_BOUNDS`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- A user attempts to make a payment with a non-positive amount\n\n**Resolution:** Ensure the payment amount is a positive value.\n\n</details>\n\n\n---\n\n### Payment Flow Not Found\n\n\n`PAYMENT_FLOW_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis usually means that:\n\n- The user is trying to use a flow that doesn't exist - The flow doesn't belong to them - The flow has expired or been completed\n\n**Resolution:** Initiate a new payment flow or check the flow ID.\n\n</details>\n\n\n---\n\n### Payment Flow in Invalid State\n\n\n`PAYMENT_FLOW_INVALID_STATE`\n\n<details>\n<summary>Details</summary>\nThis error occurs when: - The payment flow is in a state that doesn't allow the requested operation - The flow has already been processed or cancelled - The flow has expired\n\n**Resolution:** Check the current status of the payment flow before\n\n</details>\n\n\n---\n\n### Payment Flow Not Awaiting Approval\n\n\n`PAYMENT_FLOW_NOT_AWAITING_APPROVAL`\n\n<details>\n<summary>Details</summary>\nThis error is usually thrown when:\n\n- An administrator tries to approve a flow that is not in the \"awaiting approval\" state - The flow has already been processed or cancelled\n\n**Resolution:** Check the current status of the payment flow before attempting approval.\n\n</details>\n\n\n---\n\n### Payment Provider Not Found\n\n\n`PAYMENT_PROVIDER_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The payment provider ID provided doesn't exist in the system - The payment provider has been removed or deactivated - We could not choose a payment provider for the payment operation\n\n**Resolution:** Verify the payment provider ID and ensure it's still active in the system.\n\n</details>\n\n\n---\n\n### Payment Provider Not Available\n\n\n`NO_PAYMENT_PROVIDER_AVAILABLE`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- There are no payment providers available for the requested operation - There are payment providers available, but are not enabled in the system\n\n**Resolution:** Ensure that the payment providers are enabled in the system and that the user operation is supported by the available payment providers.\n\n</details>\n\n\n---\n\n### Payment method Not Found\n\n\n`PAYMENT_METHOD_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The payment method ID provided doesn't exist in the system - The payment method has been removed or deactivated - We could not choose a payment method for the payment operation\n\n**Resolution:** Verify the payment method ID and ensure it's still active in the system.\n\n</details>\n\n\n---\n\n### KYC Provider Not Found\n\n\n`KYC_PROVIDER_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The KYC provider ID provided doesn't exist in the system - The KYC provider has been removed or deactivated - We could not choose a KYC provider for the KYC operation\n\n**Resolution:** Verify the KYC provider ID and ensure it's still active in the system.\n\n</details>\n\n\n---\n\n### Search Index Not Found\n\n\n`SEARCH_INDEX_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The search index requested doesn't exist in the system - The requester doesn't have access to the specified search index\n\n**Resolution:** Verify the search index name and ensure the requester has the necessary permissions.\n\n</details>\n\n\n---\n\n### User Could Not Be Found\n\n\n`USER_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user doesn't exist in the system - The user account has been disabled or deleted\n\n**Resolution:** Verify the user ID and ensure the account is active.\n\n</details>\n\n\n---\n\n### User Is Missing a Required Payment Method Key Value\n\n\n`USER_MISSING_PAYMENT_METHOD_ACCOUNT_TYPE_IDENTIFIER`\n\n<details>\n<summary>Details</summary>\nPayment methods may support multiple sub-accounts the user has with the method. As an example, PIX supports the following payment key types:\n\n- CPF (individual taxpayer registry) - CNPJ (corporate taxpayer registry) - Email - Bank-provided UUID\n\nThis error occurs when the user has not set up a Payment method key value for the specified type.\n\n**Resolution:** Add the required payment method key value for the specified type in the user's profile.\n\n</details>\n\n\n---\n\n### User Is Missing a Document\n\n\n`USER_MISSING_DOCUMENT`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user attempts to interact with an API that requires a document - The user's profile does not have a document associated with it\n\n**Resolution:** Add a valid document to the user's profile.\n\n</details>\n\n\n---\n\n### User Has an Invalid document\n\n\n`USER_INVALID_DOCUMENT`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user attempts to interact with an API that requires a valid document - The document associated with the user's profile is not valid or properly formatted\n\n**Resolution:** Update the user's profile with a valid document.\n\n</details>\n\n\n---\n\n### User Address Missing\n\n\n`USER_ADDRESS_MISSING`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user attempts to interact with API endpoints that require an address, such as payments\n\n**Resolution:** Add an address to the user's profile.\n\n</details>\n\n\n---\n\n### User KYC required\n\n\n`USER_KYC_REQUIRED`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user does not yet have a KYC completion - The old KYC completion has expired\n\n**Resolution:** Complete the KYC process before proceeding, by completing the KYC flow.\n\n</details>\n\n\n---\n\n### User Is Excluded\n\n\n`USER_EXCLUDED`\n\n<details>\n<summary>Details</summary>\nThis error occurs when: - The user has excluded themselves from the casino - The user has been excluded by the casino\n\n**Resolution:** The user must await the exclusion period to end before being able to access the casino again.\n\n</details>\n\n\n---\n\n### User Is Blocked\n\n\n`USER_BLOCKED`\n\n<details>\n<summary>Details</summary>\nThis error occurs when: - The user has been blocked by the casino\n\n**Resolution:** The user must contact support to resolve the issue.\n\n</details>\n\n\n---\n\n### The Jurisdiction Is Not Supported\n\n\n`JURISDICTION_NOT_SUPPORTED_NO_ALTERNATIVE_SITE`\n\n<details>\n<summary>Details</summary>\nThe jurisdiction from which the API is being accessed is not supported. This may be due to missing licenses or the jurisdiction not being enabled in the system.\n\n</details>\n\n\n---\n\n### The Jurisdiction Is Not Supported, Alternative Site Available\n\n\n`JURISDICTION_NOT_SUPPORTED_ALTERNATIVE_SITE`\n\n<details>\n<summary>Details</summary>\nThe jurisdiction from which the API is being accessed is not supported, but an alternative site is available.\n\n</details>\n\n\n---\n\n### User Account Jurisdiction Mismatch\n\n\n`USER_ACCOUNT_JURISDICTION_MISMATCH`\n\n<details>\n<summary>Details</summary>\nThe request jurisdiction deviates from the user's signup jurisdiction. This can happen if the user uses a VPN or proxy to access the service, or just traveled abroad. While using a VPN is valid, and is allowed by our system, it's important that the user's request may only be processed if the user's signup jurisdiction and the request jurisdiction are covered by the same license. This ensures compliance with regulatory requirements, while still allowing users to access the service from different locations.\n\n**Important:** Compliance regulations usually forbid us from telling the user that their VPN or proxy is the reason for the error. Instead, we should inform them that their network configuration is not supported. This might serve as a hint to the user that they should disable or change their VPN or proxy.\n\n</details>\n\n\n---\n\n### The Jurisdiction Is Supported But Not Enabled\n\n\n`JURISDICTION_SUPPORTED_BUT_NOT_ENABLED`\n\n<details>\n<summary>Details</summary>\nThe jurisdiction is supported by the system but is not enabled. Supported by the system means that the system means that there is a license that covers the jurisdiction, but it is not enabled via the system jurisdiction whitelist.\n\n**Resolution:** Enable the jurisdiction in the system.\n\n</details>\n\n\n---\n\n### Host Not Supported\n\n\n`HOST_NOT_SUPPORTED`\n\n<details>\n<summary>Details</summary>\nThe requested Site (identified via the `Host` header) is not set up in the system.\n\nThis error occurs when:\n\n- The API request is made to a hostname that is not recognized or configured in the system - The Site corresponding to the hostname has been deactivated or removed\n\n**Resolution:** Verify the correct hostname for the API request or contact support to set up the required Site.\n\n</details>\n\n\n---\n\n### Game Not Found\n\n\n`GAME_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThe requested game was not found in the system.\n\nThis error occurs when:\n\n- The game ID provided doesn't exist in the system - The game has been removed or deactivated\n\n**Resolution:** Verify the game ID and ensure it's still active in the system.\n\n</details>\n\n\n---\n\n### Game Provider Not Reachable\n\n\n`GAME_PROVIDER_NOT_REACHABLE`\n\n<details>\n<summary>Details</summary>\nThe game provider or aggregator is not reachable.\n\nThis error occurs when:\n\n- The system cannot establish a connection with the game provider or aggregator - The game provider or aggregator service is down or experiencing issues\n\n**Resolution:** Try again later or contact support if the issue persists.\n\n</details>\n\n\n---\n\n### Game Provider Not Found\n\n\n`GAME_PROVIDER_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThe game provider was not found. This error occurs when: - The game provider ID provided doesn't exist in the system\n\n</details>\n\n\n---\n\n### Game Aggregator Game Provider Mapping Not Found\n\n\n`GAME_AGGREGATOR_PROVIDER_MAPPING_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThe game aggregator game provider mapping was not found. This error occurs when: - The game aggregator is not yet mapped to the game provider in the system\n\n</details>\n\n\n---\n\n### Game Aggregator Not Supported\n\n\n`GAME_AGGREGATOR_NOT_SUPPORTED`\n\n<details>\n<summary>Details</summary>\nThe game aggregator for the requested game is not supported by the system.\n\nThis error occurs when:\n\n- The system doesn't have integration with the required game aggregator - The aggregator support has been removed or is temporarily disabled\n\n**Resolution:** Choose a game from a supported aggregator or contact support for more information.\n\n</details>\n\n\n---\n\n### Game Aggregator Missing\n\n\n`GAME_AGGREGATOR_MISSING`\n\n<details>\n<summary>Details</summary>\nThis error may occur when: - A game aggregator is removed from our system, leaving orphaned games if no other aggregator publishes them\n\n</details>\n\n\n---\n\n### Game Aggregator Not Found\n\n\n`GAME_AGGREGATOR_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThe game aggregator was not found. This error occurs when: - The game aggregator ID provided doesn't exist in the system\n\n</details>\n\n\n---\n\n### Game URL Invalid\n\n\n`GAME_URL_INVALID`\n\n<details>\n<summary>Details</summary>\nThe game URL returned by the game provider is invalid.\n\nThis error occurs when:\n\n- The game provider returns a malformed or non-existent URL - The game might have been removed or relocated by the provider\n\n**Resolution:** Try again or choose a different game. If the issue persists, contact support.\n\n</details>\n\n\n---\n\n### Signup Flow Not Found\n\n\n`SIGNUP_FLOW_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The signup flow has already been completed - The flow has expired and been garbage collected - The flow ID provided never existed\n\n**Resolution:** Start a new signup flow or verify the flow ID if you believe this is an error.\n\n</details>\n\n\n---\n\n### Signup With Invalid Profile\n\n\n`SIGNUP_INVALID_PROFILE`\n\n<details>\n<summary>Details</summary>\nThis error can occur due to various reasons:\n\n- The user is blacklisted - The user's profile is incomplete or invalid - The user is underage for the service - Other regulatory or compliance issues\n\n**Resolution:** Review the signup requirements and ensure all necessary information is provided and valid.\n\n</details>\n\n\n---\n\n### Exchange Rate Not Found\n\n\n`EXCHANGE_RATE_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThe required exchange rate for the requested currency conversion could not be found.\n\nThis error occurs when:\n\n- The system doesn't have up-to-date exchange rate information for the requested currency pair - One or both of the currencies in the conversion are not supported\n\n**Resolution:** Try again later or use a different currency pair. If the issue persists, contact support.\n\n</details>\n\n\n---\n\n### Payload Signature Verification Failed\n\n\n`INVALID_SIGNATURE`\n\n<details>\n<summary>Details</summary>\nThis error mainly occurs with integrations that send signed payloads. It can happen when:\n\n- The signature is missing or malformed - The signature doesn't match the payload content - The signing key used is invalid or has been revoked\n\n**Resolution:** Check the signature generation process and ensure the correct keys are being used.\n\n</details>\n\n\n---\n\n### Invalid Request\n\n\n`MISSING_HEADER`\n\n<details>\n<summary>Details</summary>\nThis error occurs when: - The request is missing required headers\n\n**Resolution:** Ensure the request includes all required headers\n\n</details>\n\n\n---\n\n### Invalid Payload Encoding\n\n\n`INVALID_ENCODING`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The payload is malformed or corrupted - The payload format doesn't match the expected format (e.g., invalid JSON) - The payload encoding is not recognized by the system\n\n**Resolution:** Verify the payload format and encoding, ensuring it matches the API specifications.\n\n</details>\n\n\n---\n\n### Missing Sec-WebSocket-Protocol Header\n\n\n`MISSING_SEC_WEB_SOCKET_PROTOCOL`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- A client attempts to establish a WebSocket connection without providing the necessary protocol header - The header is malformed or contains unsupported protocols\n\n**Resolution:** Ensure the WebSocket connection request includes a valid `Sec-WebSocket-Protocol` header.\n\n</details>\n\n\n---\n\n### Invalid User Geolocation\n\n\n`INVALID_USER_GEOLOCATION`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- A request that requires geolocation data (e.g., CF-IPCountry) is made without this information - The geolocation information is present but invalid or in an unsupported format\n\n**Resolution:** Ensure the request includes valid geolocation information, typically provided through specific headers.\n\n</details>\n\n\n---\n\n### Invalid Bot Header\n\n\n`INVALID_BOT_HEADER`\n\n<details>\n<summary>Details</summary>\nThis error occurs when: - A request sends a `X-Bot` header with an invalid value\n\n</details>\n\n\n---\n\n### Lease Not Found\n\n\n`LEASE_NOT_FOUND`\n\n<details>\n<summary>Details</summary>\nThe requested lease for establishing a WebSocket connection could not be found or has expired.\n\nLeases are used by the WebSocket system to create short-lived tickets that the user uses to establish a WebSocket connection. This error occurs when:\n\n- The lease ID provided doesn't exist - The lease has expired before the WebSocket connection was established - The lease has already been used and is no longer valid\n\n**Resolution:** Request a new lease and attempt to establish the WebSocket connection again.\n\n</details>\n\n\n---\n\n### Validation Failed\n\n\n`VALIDATION`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The payload doesn't meet the required format or data constraints - Required fields are missing or contain invalid values - The payload violates business logic rules\n\n**Resolution:** Review the API documentation for the correct payload format and constraints. Adjust the payload accordingly.\n\n</details>\n\n\n---\n\n### Invalid Content Type\n\n\n`INVALID_CONTENT_TYPE`\n\n<details>\n<summary>Details</summary>\nThis error occurs when: - The content type of the request is not supported\n\n**Resolution:** Ensure the content type of the request is supported\n\n</details>\n\n\n---\n\n### Unauthorized\n\n\n`UNAUTHORIZED`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user is not authenticated - The user lacks the necessary permissions to access the resource - The authentication token has expired or is invalid\n\n**Resolution:** Ensure the user is properly authenticated and has the required permissions. If necessary, refresh the authentication token.\n\n</details>\n\n\n---\n\n### Forbidden\n\n\n`FORBIDDEN`\n\n<details>\n<summary>Details</summary>\nThis error occurs when:\n\n- The user is not authenticated - The user lacks the necessary permissions to access the resource - The authentication token has expired or is invalid\n\n**Resolution:** Ensure the user is properly authenticated and has the required permissions. If necessary, refresh the authentication token.\n\n</details>\n\n\n---\n\n### Internal Error\n\n\n`INTERNAL`\n\n<details>\n<summary>Details</summary>\nThis error should never be thrown under normal circumstances. If it occurs, it indicates a severe problem within the system.\n\nPossible causes include:\n\n- Unhandled exceptions in the server code - Database connection failures - Critical system resource exhaustion\n\n**Resolution:** Contact the system administrators or support team immediately. Provide them with any error codes or messages received.\n\n</details>\n\n",
    "version": "0.8.0"
  },
  "paths": {
    "/": {
      "get": {
        "tags": [
          "System"
        ],
        "summary": "API Root",
        "description": "The root of the API",
        "responses": {
          "200": {
            "description": "plain text",
            "content": {
              "text/plain; charset=utf-8": {}
            }
          }
        }
      }
    },
    "/health": {
      "get": {
        "tags": [
          "System"
        ],
        "summary": "Health Check",
        "description": "Check the health of the system",
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/liveness": {
      "get": {
        "tags": [
          "System"
        ],
        "summary": "Liveness Check",
        "description": "Check the liveness of the system",
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/whoami": {
      "get": {
        "tags": [
          "Authentication"
        ],
        "summary": "Whoami",
        "description": "The whoami endpoint returns some basic information about the currently logged in user.\nThis is primarily used for verifying that the user is logged in.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WhoamiResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/login": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "Login",
        "description": "User login form.\nThe response will set a cookie and redirect to the 'next' URL, if provided.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "302": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/logout": {
      "get": {
        "tags": [
          "Authentication"
        ],
        "summary": "Logout",
        "description": "User logout, that will unset the login session cookie if naviaged to.",
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/forgot-password": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "Password reset request",
        "description": "This endpoint will take a user email and send out a password reset email to the user.\nThe email will contain a link that the user can click on to reset their password. The link will be valid for 60 minutes.\nNote that this endpoint will always return a 200 status code, even if the email does not exist in the database.\nThis is to prevent attackers from using this endpoint to determine if an email exists in the database.\nThe endpoint will also always take the same amount of time to respond, regardless of whether the email exists in the database or not.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InitializePasswordResetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/reset-password": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "Password reset",
        "description": "This endpoint takes a password reset token and the newly chosen password from the user.\nThe token is sent to the user's email when they request a password reset.\nIf the token is valid, the user's password will be updated to the new password.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FinalizePasswordResetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/signup/flow": {
      "get": {
        "tags": [
          "Signup"
        ],
        "summary": "Create Signup Flow",
        "description": "Create a new signup flow that can be incrementally patched and the submitted for completion.\nThis endpoint requires the `CF-IPCountry` header to be set and to be a valid jurisdiction.\nThis header is normally set by Cloudflare and is used to determine the jurisdiction of the user,\nbuy you may also set it manually during development.\nNote that you may need to configure the CORS settings to allow the `CF-IPCountry` header to be sent.\n\nThe ID returned by the signup flow can be stored in the frontend URL or other storage\nto recover the signup flow if the user reloads the page or does other destructive actions.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateSignupFlowResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/signup/flow/{flow_id}": {
      "get": {
        "tags": [
          "Signup"
        ],
        "summary": "Get Signup Flow",
        "description": "Get the specified signup flow and all the fields that have been added to it.\nUse this for recovering form data if the user reloads the page or does other destructive actions.",
        "parameters": [
          {
            "in": "path",
            "name": "flow_id",
            "description": "The ID of the signup flow to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the signup flow to retrieve.",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignupFlowResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Signup"
        ],
        "summary": "Submit Signup Flow",
        "description": "Submit the specified signup flow and create the user entry.\nThis can fail if certain validation of fields and jurisdiction dependent information is unsuccessful.",
        "parameters": [
          {
            "in": "path",
            "name": "flow_id",
            "description": "The ID of the signup flow to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the signup flow to retrieve.",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Signup"
        ],
        "summary": "Update Signup Flow",
        "description": "\nPatch the specified signup flow with additional information.\n\nExample request body for brazilian users:\n```\n {\n\t\"first_name\": \"John\",\n\t\"last_name\": \"Doe\",\n\t\"email\": \"john@doe.com\",\n\t\"password\": \"test\",\n\t\"CPF\": \"549.448.010-09\"\n}\n```\n\n#### Testing CPFs that you can use to create a user\n\n- 549.448.010-09\n- 653.358.910-50\n- 715.176.900-80\n- 395.677.760-32\n- 993.093.100-73\n",
        "parameters": [
          {
            "in": "path",
            "name": "flow_id",
            "description": "The ID of the signup flow to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the signup flow to retrieve.",
              "type": "string"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchSignupFlowRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/payment/deposit": {
      "post": {
        "tags": [
          "Payment"
        ],
        "summary": "Create Deposit Flow",
        "description": "Create a new deposit flow.\n    This flow will be active as long as we don't receive a\n    confirmation from our payment providers, that a deposit has been completed.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaymentTransactionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateDepositFlowResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/payment/withdraw": {
      "post": {
        "tags": [
          "Payment"
        ],
        "summary": "Create Withdrawal Flow",
        "description": "Create a withdrawal flow.\n    This flow will be active as long as we don't receive a confirmation from our payment provider,\n    that they have successfully withdrawn the desired amount into the user's bank account.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaymentTransactionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateWithdrawalFlowResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/payment/list": {
      "get": {
        "tags": [
          "Payment"
        ],
        "summary": "List Payment Flows",
        "description": "List all payment flows for the currently logged in user.",
        "parameters": [
          {
            "in": "query",
            "name": "payment_type",
            "description": "The payment type to filter the payment flows by. If not set, all payment types will be included.",
            "schema": {
              "description": "The payment type to filter the payment flows by. If not set, all payment types will be included.",
              "anyOf": [
                {
                  "$ref": "#/components/schemas/PaymentType"
                },
                {
                  "type": "null"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wallet_id",
            "description": "The wallet ID to filter the payment flows by. If not set, all wallets of the user will be included.",
            "schema": {
              "description": "The wallet ID to filter the payment flows by. If not set, all wallets of the user will be included.",
              "anyOf": [
                {
                  "$ref": "#/components/schemas/WalletId"
                },
                {
                  "type": "null"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 20,
              "type": "integer",
              "format": "uint",
              "maximum": 100.0,
              "minimum": 1.0
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "offset",
            "schema": {
              "default": 0,
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatorResponse_for_PaymentFlowResponse_and_ListPaymentFlowsQuery"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/payment/limits": {
      "get": {
        "tags": [
          "Payment"
        ],
        "summary": "Get Payment Limits",
        "description": "Get the payment limits for the currently logged in user.",
        "parameters": [
          {
            "in": "query",
            "name": "currency",
            "description": "The currency to get the payment limits for.",
            "required": true,
            "schema": {
              "description": "The currency to get the payment limits for.",
              "$ref": "#/components/schemas/Currency"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "payment_method_id",
            "description": "The payment method to get the payment limits for.",
            "required": true,
            "schema": {
              "description": "The payment method to get the payment limits for.",
              "$ref": "#/components/schemas/PaymentMethodId"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaymentLimitsResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/payment/methods": {
      "get": {
        "tags": [
          "Payment"
        ],
        "summary": "Get Payment Methods",
        "description": "Get all payment methods that can be used by the the user for the given currency.",
        "parameters": [
          {
            "in": "query",
            "name": "currency",
            "description": "The currency to get the payment methods for.",
            "required": true,
            "schema": {
              "description": "The currency to get the payment methods for.",
              "$ref": "#/components/schemas/Currency"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PaymentMethodResponse"
                  }
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/payment/{flow_id}": {
      "get": {
        "tags": [
          "Payment"
        ],
        "summary": "Get Payment Flow",
        "description": "Get a payment flow by its ID.",
        "parameters": [
          {
            "in": "path",
            "name": "flow_id",
            "description": "The ID of the payment flow.",
            "required": true,
            "schema": {
              "description": "The ID of the payment flow.",
              "$ref": "#/components/schemas/PaymentFlowId"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaymentFlowResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/system/licenses": {
      "get": {
        "tags": [
          "Meta"
        ],
        "summary": "Get Matched Licenses",
        "description": "Get the available system licenses for the requested jurisdiction/site header combination.\n        The licenses are ordered in their priority order,\n        and thus the first license in the list is the most preferred one.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LicenseResponse"
                  }
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/system/site": {
      "get": {
        "tags": [
          "Meta"
        ],
        "summary": "Get Matched Site",
        "description": "The the matched site based on the host header.\n        Use this to differentiate between different sites in a multi-site setup,\n        allowing for different configurations, themes, etc.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/system/preflight": {
      "get": {
        "tags": [
          "Meta"
        ],
        "summary": "Preflight Check",
        "description": "This preflight endpoint should be the first endpoint\n        to be called by the client or the SSR implementation.\n        It is used to check if the user is able to access the\n        host + jurisdiction combination. Should they not be allowed to access\n        the site, the endpoint will return a `JURISDICTION_NOT_SUPPORTED` error,\n        possibly containing a list of alternative sites that the user can access.\n        ",
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game-provider/search": {
      "get": {
        "tags": [
          "Game Provider"
        ],
        "summary": "Search Game Providers",
        "description": "Search for games providers by providing a search query.",
        "parameters": [
          {
            "in": "query",
            "name": "query",
            "description": "An organic search query to find game providers by. Searched fields include but are not limited to: name, description, slug...",
            "schema": {
              "description": "An organic search query to find game providers by. Searched fields include but are not limited to: name, description, slug...",
              "type": [
                "string",
                "null"
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 20,
              "type": "integer",
              "format": "uint",
              "maximum": 100.0,
              "minimum": 1.0
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "offset",
            "schema": {
              "default": 0,
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatorResponse_for_SearchGameProviderResponse_and_SearchGameProviderQuery"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game-provider/{provider_id}": {
      "get": {
        "tags": [
          "Game Provider"
        ],
        "summary": "Get Game Provider",
        "description": "Get a game provider by its ID.\n        This can be used to show a more detailed view of of the\n        provider profile in the frontend, which may require more data than\n        the search endpoint provides.",
        "parameters": [
          {
            "in": "path",
            "name": "provider_id",
            "description": "The ID of the game provider.",
            "required": true,
            "schema": {
              "description": "The ID of the game provider.",
              "$ref": "#/components/schemas/GameProviderId"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameProviderResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/{game_id}/session": {
      "get": {
        "tags": [
          "Game"
        ],
        "summary": "Create Game Session",
        "description": "Create a new game session by providing the game ID,\n    as well as the currency with which the game should be played with,\n    and the client type of the user.\n    The response will redirect the user to the third party URL of the game provider.\n    Please note that this request should be used in conjunction with an iframe,\n    so that the user does not get redirected from the casino website.",
        "parameters": [
          {
            "in": "path",
            "name": "game_id",
            "description": "The ID of the game to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the game to retrieve.",
              "$ref": "#/components/schemas/GameId"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "client_type",
            "description": "The device type the game session is started on. Some games may only be available on certain devices.",
            "required": true,
            "schema": {
              "description": "The device type the game session is started on. Some games may only be available on certain devices.",
              "$ref": "#/components/schemas/Device"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "currency",
            "description": "The currency (wallet) to use for the game session. It can not be changed during the session.",
            "required": true,
            "schema": {
              "description": "The currency (wallet) to use for the game session. It can not be changed during the session.",
              "$ref": "#/components/schemas/Currency"
            },
            "style": "form"
          }
        ],
        "responses": {
          "307": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/search": {
      "get": {
        "tags": [
          "Game"
        ],
        "summary": "Search Games",
        "description": "Search for games by providing a search query.",
        "parameters": [
          {
            "in": "query",
            "name": "category",
            "description": "The category identifier to filter games by. If set, only games in this category are returned. Note: this is not the category ID, but the identifier.",
            "schema": {
              "description": "The category identifier to filter games by. If set, only games in this category are returned. Note: this is not the category ID, but the identifier.",
              "type": [
                "string",
                "null"
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "provider_id",
            "description": "The provider to filter games by. If set, only games by this provider are returned.",
            "schema": {
              "description": "The provider to filter games by. If set, only games by this provider are returned.",
              "type": [
                "integer",
                "null"
              ],
              "format": "int64"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "query",
            "description": "An organic search query to find games by. Searched fields include but are not limited to: name, description, provider name...",
            "schema": {
              "description": "An organic search query to find games by. Searched fields include but are not limited to: name, description, provider name...",
              "type": [
                "string",
                "null"
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 20,
              "type": "integer",
              "format": "uint",
              "maximum": 100.0,
              "minimum": 1.0
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "offset",
            "schema": {
              "default": 0,
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatorResponse_for_SearchGameResponse_and_SearchGameQuery"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/action/list": {
      "get": {
        "tags": [
          "Game"
        ],
        "summary": "List Game Actions",
        "description": "Get a list of all game actions of the user. ",
        "parameters": [
          {
            "in": "query",
            "name": "action_type",
            "description": "The type of the game action to filter by. If not set, all game actions (bet, win, etc.) will be included.",
            "schema": {
              "description": "The type of the game action to filter by. If not set, all game actions (bet, win, etc.) will be included.",
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ListGameActionsTypeQuery"
                },
                {
                  "type": "null"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "game_id",
            "description": "Game ID to filter the game actions by. If not set, all game actions will be included.",
            "schema": {
              "description": "Game ID to filter the game actions by. If not set, all game actions will be included.",
              "anyOf": [
                {
                  "$ref": "#/components/schemas/GameId"
                },
                {
                  "type": "null"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 20,
              "type": "integer",
              "format": "uint",
              "maximum": 100.0,
              "minimum": 1.0
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "offset",
            "schema": {
              "default": 0,
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatorResponse_for_GameActionResponse_and_ListGameActionsQuery"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/category/list": {
      "get": {
        "tags": [
          "Game"
        ],
        "summary": "Get Available Game Categories",
        "description": "Get a list of all game categories available in the casino.\n    This can be used to show a list of game categories to the user,\n    so that they can choose which category they want to explore.\n    There are two major types of categories, staic and dynamic.\n    Static categories are predefined by the casino, while dynamic categories\n    cover games based on user behavior and other factors.\n    Dynamic categories are recalcuated periodically.",
        "parameters": [
          {
            "in": "query",
            "name": "group",
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/CategoryGroup"
                },
                {
                  "type": "null"
                }
              ]
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CategoryResponse"
                  }
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/{game_id}/rating": {
      "post": {
        "tags": [
          "Game"
        ],
        "summary": "Rate Game",
        "description": "Rate a game by its ID.\n    This can be used to allow users to rate games,\n    so that other users can see the rating of the game.\n    Sending a rating of null will remove the rating of the user.",
        "parameters": [
          {
            "in": "path",
            "name": "game_id",
            "description": "The ID of the game to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the game to retrieve.",
              "$ref": "#/components/schemas/GameId"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RateGameRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/{game_id}/ratings": {
      "get": {
        "tags": [
          "Game"
        ],
        "summary": "Get Game Ratings",
        "description": "User ratings split up into likes and dislikes",
        "parameters": [
          {
            "in": "path",
            "name": "game_id",
            "description": "The ID of the game to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the game to retrieve.",
              "$ref": "#/components/schemas/GameId"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameRatingsResponse"
                }
              }
            }
          },
          "204": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/game/{game_id}": {
      "get": {
        "tags": [
          "Game"
        ],
        "summary": "Get Game",
        "description": "Get a game by its ID. This can be used to show a more detailed view of a game,\n    including its name, description,\n    and other metadata, that might be required to display the game on the frontend.",
        "parameters": [
          {
            "in": "path",
            "name": "game_id",
            "description": "The ID of the game to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the game to retrieve.",
              "$ref": "#/components/schemas/GameId"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GameResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/notification/list": {
      "get": {
        "tags": [
          "Notification"
        ],
        "summary": "Get All Notifications",
        "description": "Get a list of all notifications for the current user.",
        "parameters": [
          {
            "in": "query",
            "name": "read_status",
            "description": "The read status of the notifications to filter by.",
            "schema": {
              "description": "The read status of the notifications to filter by.",
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ReadStatus"
                },
                {
                  "type": "null"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "types",
            "description": "The types of the notifications to filter by.",
            "schema": {
              "description": "The types of the notifications to filter by.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/components/schemas/NotificationTypeDiscriminants"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 20,
              "type": "integer",
              "format": "uint",
              "maximum": 100.0,
              "minimum": 1.0
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "offset",
            "schema": {
              "default": 0,
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatorResponse_for_NotificationResponse_and_ListNotificationsQuery"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/notification/{notification_id}/read-status": {
      "patch": {
        "tags": [
          "Notification"
        ],
        "summary": "Update Notification Read Status",
        "description": "Mark a notification as read.",
        "parameters": [
          {
            "in": "path",
            "name": "notification_id",
            "description": "The ID of the notification to retrieve.",
            "required": true,
            "schema": {
              "description": "The ID of the notification to retrieve.",
              "$ref": "#/components/schemas/NotificationId"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReadStatus"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/profile": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Get User Profile",
        "description": "Get the user profile of the currently logged in user.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/balance": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Get User Balance",
        "description": "Get the balance of the currently logged in user. The wallets are returned in the order of their selection. Frontends mays utilize this order to display the wallets, and to identify the active wallet.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserBalanceResponse"
                  }
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/settings": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Get User Settings",
        "description": "Get the settings of the currently logged in user.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PatchUserSettingsRequest"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Update User Settings",
        "description": "Update the settings of the currently logged in user.\n\nThis endpoint allows for partial updates of the user settings, by\nonly updating the fields that are provided in the request.\n\nIf a field is set to `null`, it will be reset to the default value.\n\nIf a field is not provided, it will not be updated.\n\nPartial updates follow the [RFC 7396](https://datatracker.ietf.org/doc/html/rfc7396) JSON Merge Patch standard.\n\n```json\n// Given the following JSON\n{\n\t\"title\": \"Goodbye!\",\n\t\"author\" : {\n\t\t\"givenName\" : \"John\",\n\t\t\"familyName\" : \"Doe\"\n\t},\n\t\"tags\":[ \"example\", \"sample\" ],\n\t\"content\": \"This will be unchanged\"\n}\n\n// Merged with the following patch\n{\n\t\"title\": \"Hello!\",\n\t\"phoneNumber\": \"+01-123-456-7890\",\n\t\"author\": {\n\t\t\"familyName\": null\n\t},\n\t\"tags\": [ \"example\" ]\n}\n\n// Will result in the following JSON\n{\n\t\"title\": \"Hello!\",\n\t\"author\" : {\n\t\t\"givenName\" : \"John\"\n\t},\n\t\"tags\": [ \"example\" ],\n\t\"content\": \"This will be unchanged\",\n\t\"phoneNumber\": \"+01-123-456-7890\"\n}\n```",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchUserSettingsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/address": {
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Update User Address",
        "description": "Update the address of the currently logged in user. The address is used for shipping and other purposes.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchUserAddressRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/active-wallet": {
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Update User Active Wallet",
        "description": "Update the selected wallet of the user. The user balance endpoint will return the user's wallets in the order of their selection time.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SelectWalletRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/password": {
      "patch": {
        "tags": [
          "User"
        ],
        "summary": "Update User Password",
        "description": "Update the password of the currently logged in user. The current password is required to ensure that the user is authorized to change the password.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchUserPasswordRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/user/delete": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Delete User Account",
        "description": "Delete the account of the currently logged in user. The user must provide the current password to ensure that they are authorized to delete the account.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteUserAccountRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "no content"
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/kyc/token": {
      "get": {
        "tags": [
          "KYC"
        ],
        "summary": "Get KYC Access Token",
        "description": "This endpoint returns a temporary short-lived token that is bound to the user.\nIt can be used in conjunction with a KYC provider's SDK to perform KYC validation in the frontend.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KycAccessTokenResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/kyc/status": {
      "get": {
        "tags": [
          "KYC"
        ],
        "summary": "Get KYC Status",
        "description": "Returns the current KYC status of the user.\nThis endpoint may be used to prevent the user from going through the KYC process again if they have already completed it.\n",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KycStatusResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/ws/lease": {
      "post": {
        "tags": [
          "WebSocket"
        ],
        "summary": "Issue WebSocket Lease",
        "description": "This endpoint is used to generate authentication tokens (leases) for WebSocket connections in our system.\n\n## Lease Generation\n\n1. Send a request to the lease issuer endpoint.\n2. Specify the channel for which you want a lease.\n3. The endpoint will return a lease token.\n\n## Lease Properties\n\n- Leases are short-lived tokens, valid for 60 seconds from the time of generation.\n- Each lease is tied to a specific channel.\n\n## Usage\n\n- Use the generated lease token when establishing a WebSocket connection.\n- For detailed information on how to use the lease token in a WebSocket connection, refer to the documentation found [here](#tag/websocket/GET/ws/connect).\n\n## Important Notes\n\n- Always generate a new lease before attempting to establish a WebSocket connection.\n- Ensure your client handles lease expiration and reconnection scenarios.\n\nFor any issues or questions, please contact our support team.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebsocketLeaseRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LeaseTokenResponse"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    },
    "/ws/connect": {
      "get": {
        "tags": [
          "WebSocket"
        ],
        "summary": "Establish WebSocket Connection",
        "description": "This route is the entry point for WebSocket connections in our system.\n\n## Authentication\n\n- Authentication is required for all WebSocket connections.\n- Use a lease token obtained from the lease handler endpoint.\n\n## Connection Process\n\n1. Obtain a lease token from the lease handler endpoint.\n2. Connect to this endpoint using the WebSocket protocol.\n3. Set the `sec-websocket-protocol` header as follows:\n\n   ```text\n   Authorization,<lease-token>\n   ```\n\n## Example (JavaScript)\n\n```javascript\nconst leaseToken = \"your-lease-token\";\nconst socket = new WebSocket(\"wss://your-domain.com/ws/connect\", [\"Authorization\", leaseToken]);\n```\n\n## Important Notes\n\n- Lease tokens are valid for 60 seconds.\n- Ensure your client can handle reconnection if the lease expires.\n- The server may close the connection if authentication fails.\n\nFor detailed information on lease generation and management, refer to the main WebSocket authentication documentation found [here](#tag/websocket/POST/ws/lease).",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RtcEventPayload"
                }
              }
            }
          },
          "4XX": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AlternativeSite": {
        "type": "object",
        "required": [
          "base_url",
          "name",
          "servable"
        ],
        "properties": {
          "base_url": {
            "description": "The base URL of the alternative site. This url should be used to redirect the user to the alternative site. The URL may include a path too, so this needs to be taken into account.",
            "$ref": "#/components/schemas/Url"
          },
          "name": {
            "description": "The name of the alternative site.",
            "type": "string"
          },
          "servable": {
            "description": "The field \"servable\" indicates if this site is able to be served by the current casino instance. If there's an alternative, which can not be served by the current casino instance, but can be served by another casino instance, this is false. Example scenario: Cross-regional deployments of this system, with independent databases require the ability to point to each other as alternatives, as they can't serve the requested site themselves.",
            "type": "boolean"
          }
        }
      },
      "CategoryGroup": {
        "type": "string",
        "enum": [
          "home",
          "game_page",
          "inventory"
        ]
      },
      "CategoryResponse": {
        "type": "object",
        "required": [
          "id",
          "identifier"
        ],
        "properties": {
          "id": {
            "description": "The ID of the game category.",
            "$ref": "#/components/schemas/GameCategoryId"
          },
          "identifier": {
            "description": "The identifier of the game category. This is a unique string that can be used to identify the category in the game search endpoint.",
            "type": "string"
          }
        }
      },
      "Country": {
        "description": "A country represented by its ISO 3166-1 alpha-2 code.",
        "examples": [
          "US",
          "DE",
          "BR"
        ],
        "enum": [
          "AF",
          "AX",
          "AL",
          "DZ",
          "AS",
          "AD",
          "AO",
          "AI",
          "AQ",
          "AG",
          "AR",
          "AM",
          "AW",
          "AU",
          "AT",
          "AZ",
          "BS",
          "BH",
          "BD",
          "BB",
          "BY",
          "BE",
          "BZ",
          "BJ",
          "BM",
          "BT",
          "BO",
          "BQ",
          "BA",
          "BW",
          "BV",
          "BR",
          "IO",
          "BN",
          "BG",
          "BF",
          "BI",
          "CV",
          "KH",
          "CM",
          "CA",
          "KY",
          "CF",
          "TD",
          "CL",
          "CN",
          "CX",
          "CC",
          "CO",
          "KM",
          "CG",
          "CD",
          "CK",
          "CR",
          "CI",
          "HR",
          "CU",
          "CW",
          "CY",
          "CZ",
          "DK",
          "DJ",
          "DM",
          "DO",
          "EC",
          "EG",
          "SV",
          "GQ",
          "ER",
          "EE",
          "SZ",
          "ET",
          "FK",
          "FO",
          "FJ",
          "FI",
          "FR",
          "GF",
          "PF",
          "TF",
          "GA",
          "GM",
          "GE",
          "DE",
          "GH",
          "GI",
          "GR",
          "GL",
          "GD",
          "GP",
          "GU",
          "GT",
          "GG",
          "GN",
          "GW",
          "GY",
          "HT",
          "HM",
          "VA",
          "HN",
          "HK",
          "HU",
          "IS",
          "IN",
          "ID",
          "IR",
          "IQ",
          "IE",
          "IM",
          "IL",
          "IT",
          "JM",
          "JP",
          "JE",
          "JO",
          "KZ",
          "KE",
          "KI",
          "KP",
          "KR",
          "KW",
          "KG",
          "LA",
          "LV",
          "LB",
          "LS",
          "LR",
          "LY",
          "LI",
          "LT",
          "LU",
          "MO",
          "MG",
          "MW",
          "MY",
          "MV",
          "ML",
          "MT",
          "MH",
          "MQ",
          "MR",
          "MU",
          "YT",
          "MX",
          "FM",
          "MD",
          "MC",
          "MN",
          "ME",
          "MS",
          "MA",
          "MZ",
          "MM",
          "NA",
          "NR",
          "NP",
          "NL",
          "NC",
          "NZ",
          "NI",
          "NE",
          "NG",
          "NU",
          "NF",
          "MK",
          "MP",
          "NO",
          "OM",
          "PK",
          "PW",
          "PS",
          "PA",
          "PG",
          "PY",
          "PE",
          "PH",
          "PN",
          "PL",
          "PT",
          "PR",
          "QA",
          "RE",
          "RO",
          "RU",
          "RW",
          "BL",
          "SH",
          "KN",
          "LC",
          "MF",
          "PM",
          "VC",
          "WS",
          "SM",
          "ST",
          "SA",
          "SN",
          "RS",
          "SC",
          "SL",
          "SG",
          "SX",
          "SK",
          "SI",
          "SB",
          "SO",
          "ZA",
          "GS",
          "SS",
          "ES",
          "LK",
          "SD",
          "SR",
          "SJ",
          "SE",
          "CH",
          "SY",
          "TW",
          "TJ",
          "TZ",
          "TH",
          "TL",
          "TG",
          "TK",
          "TO",
          "TT",
          "TN",
          "TR",
          "TM",
          "TC",
          "TV",
          "UG",
          "UA",
          "AE",
          "GB",
          "US",
          "UM",
          "UY",
          "UZ",
          "VU",
          "VE",
          "VN",
          "VG",
          "VI",
          "WF",
          "EH",
          "YE",
          "ZM",
          "ZW"
        ]
      },
      "CreateDepositFlowResponse": {
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "pix"
            ],
            "properties": {
              "pix": {
                "type": "object",
                "required": [
                  "code"
                ],
                "properties": {
                  "code": {
                    "description": "The PIX code used by the user for depositing the amount",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ],
        "required": [
          "flow_id"
        ],
        "properties": {
          "flow_id": {
            "description": "Withdrawal payment flow ID",
            "$ref": "#/components/schemas/PaymentFlowId"
          }
        }
      },
      "CreateGameSessionQuery": {
        "type": "object",
        "required": [
          "client_type",
          "currency"
        ],
        "properties": {
          "client_type": {
            "description": "The device type the game session is started on. Some games may only be available on certain devices.",
            "$ref": "#/components/schemas/Device"
          },
          "currency": {
            "description": "The currency (wallet) to use for the game session. It can not be changed during the session.",
            "$ref": "#/components/schemas/Currency"
          }
        }
      },
      "CreateSignupFlowResponse": {
        "type": "object",
        "required": [
          "flow_id"
        ],
        "properties": {
          "flow_id": {
            "description": "The ID of the created signup flow.",
            "type": "string"
          }
        }
      },
      "CreateWithdrawalFlowResponse": {
        "type": "object",
        "required": [
          "flow_id"
        ],
        "properties": {
          "flow_id": {
            "description": "Withdrawal payment flow ID",
            "$ref": "#/components/schemas/PaymentFlowId"
          }
        }
      },
      "Currency": {
        "description": "ISO 4217 3-letter currency code or 3/4-letter crypto currency code",
        "examples": [
          "AED",
          "AFN",
          "ALL",
          "AMD",
          "ANG",
          "AOA",
          "ARS",
          "AUD",
          "AWG",
          "AZN",
          "BAM",
          "BBD",
          "BDT",
          "BGN",
          "BHD",
          "BIF",
          "BMD",
          "BND",
          "BOB",
          "BOV",
          "BRL",
          "BSD",
          "BTN",
          "BWP",
          "BYN",
          "BZD",
          "CAD",
          "CDF",
          "CHE",
          "CHF",
          "CHW",
          "CLF",
          "CLP",
          "CNY",
          "COP",
          "COU",
          "CRC",
          "CUC",
          "CUP",
          "CVE",
          "CZK",
          "DJF",
          "DKK",
          "DOP",
          "DZD",
          "EGP",
          "ERN",
          "ETB",
          "EUR",
          "FJD",
          "FKP",
          "GBP",
          "GEL",
          "GHS",
          "GIP",
          "GMD",
          "GNF",
          "GTQ",
          "GYD",
          "HKD",
          "HNL",
          "HRK",
          "HTG",
          "HUF",
          "IDR",
          "ILS",
          "INR",
          "IQD",
          "IRR",
          "ISK",
          "JMD",
          "JOD",
          "JPY",
          "KES",
          "KGS",
          "KHR",
          "KMF",
          "KPW",
          "KRW",
          "KWD",
          "KYD",
          "KZT",
          "LAK",
          "LBP",
          "LKR",
          "LRD",
          "LSL",
          "LYD",
          "MAD",
          "MDL",
          "MGA",
          "MKD",
          "MMK",
          "MNT",
          "MOP",
          "MRU",
          "MUR",
          "MVR",
          "MWK",
          "MXN",
          "MXV",
          "MYR",
          "MZN",
          "NAD",
          "NGN",
          "NIO",
          "NOK",
          "NPR",
          "NZD",
          "OMR",
          "PAB",
          "PEN",
          "PGK",
          "PHP",
          "PKR",
          "PLN",
          "PYG",
          "QAR",
          "RON",
          "RSD",
          "RUB",
          "RWF",
          "SAR",
          "SBD",
          "SCR",
          "SDG",
          "SEK",
          "SGD",
          "SHP",
          "SLE",
          "SLL",
          "SOS",
          "SRD",
          "SSP",
          "STN",
          "SVC",
          "SYP",
          "SZL",
          "THB",
          "TJS",
          "TMT",
          "TND",
          "TOP",
          "TRY",
          "TTD",
          "TWD",
          "TZS",
          "UAH",
          "UGX",
          "USD",
          "USN",
          "UYI",
          "UYU",
          "UYW",
          "UZS",
          "VED",
          "VES",
          "VND",
          "VUV",
          "WST",
          "XAF",
          "XAG",
          "XAU",
          "XBA",
          "XBB",
          "XBC",
          "XBD",
          "XCD",
          "XDR",
          "XOF",
          "XPD",
          "XPF",
          "XPT",
          "XSU",
          "XTS",
          "XUA",
          "XXX",
          "YER",
          "ZAR",
          "ZMW",
          "ZWL",
          "ZWG",
          "BTC",
          "ETH",
          "USDC",
          "USDT",
          "BCH",
          "XRP",
          "FUN",
          "ADA",
          "TRX",
          "BSV",
          "BNB",
          "NEO"
        ],
        "maxLength": 4,
        "minLength": 3,
        "pattern": "^[A-Z]{3,4}$"
      },
      "DeleteUserAccountRequest": {
        "type": "object",
        "required": [
          "current_password"
        ],
        "properties": {
          "current_password": {
            "description": "The current password of the user. This is required to ensure that the user is the one making the request.",
            "type": "string"
          },
          "reason": {
            "description": "The reason provided by the user, for deleting their account.",
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "Device": {
        "type": "string",
        "enum": [
          "mobile",
          "desktop"
        ]
      },
      "DurationSeconds": {
        "type": "integer",
        "format": "int64"
      },
      "FinalizePasswordResetRequest": {
        "type": "object",
        "required": [
          "password",
          "token"
        ],
        "properties": {
          "password": {
            "description": "The new password for the user.",
            "type": "string",
            "maxLength": 256,
            "minLength": 6
          },
          "token": {
            "description": "The token that was sent to the user and has to be included for the reset to succeed.",
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "GameActionResponse": {
        "type": "object",
        "required": [
          "action",
          "amount",
          "created_at",
          "currency",
          "game_id",
          "game_name",
          "id"
        ],
        "properties": {
          "action": {
            "description": "The type of the action that was performed. Either Bets or Wins.",
            "$ref": "#/components/schemas/GameActionType"
          },
          "amount": {
            "description": "The amount of the action. This is the amount that was bet, won, etc.",
            "$ref": "#/components/schemas/SystemAmount"
          },
          "created_at": {
            "description": "The date and time the action was performed.",
            "type": "string",
            "format": "date-time"
          },
          "currency": {
            "description": "The currency the amount was in.",
            "$ref": "#/components/schemas/Currency"
          },
          "game_id": {
            "description": "The ID of the game the action was performed on.",
            "$ref": "#/components/schemas/GameId"
          },
          "game_name": {
            "description": "The name of the game the action was performed on.",
            "type": "string"
          },
          "id": {
            "description": "The ID of the game action.",
            "$ref": "#/components/schemas/GameRoundActionId"
          }
        }
      },
      "GameActionType": {
        "type": "string",
        "enum": [
          "bet",
          "win",
          "rollback"
        ]
      },
      "GameCategoryId": {
        "type": "integer",
        "format": "int64"
      },
      "GameCategoryListFilter": {
        "type": "object",
        "properties": {
          "group": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CategoryGroup"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "GameId": {
        "type": "integer",
        "format": "int64"
      },
      "GameParams": {
        "type": "object",
        "required": [
          "game_id"
        ],
        "properties": {
          "game_id": {
            "description": "The ID of the game to retrieve.",
            "$ref": "#/components/schemas/GameId"
          }
        }
      },
      "GameProviderId": {
        "type": "integer",
        "format": "int64"
      },
      "GameProviderParams": {
        "type": "object",
        "required": [
          "provider_id"
        ],
        "properties": {
          "provider_id": {
            "description": "The ID of the game provider.",
            "$ref": "#/components/schemas/GameProviderId"
          }
        }
      },
      "GameProviderResponse": {
        "description": "The response to a game provider request. It contains all available information about the provider.",
        "type": "object",
        "required": [
          "id",
          "image_url",
          "name",
          "slug"
        ],
        "properties": {
          "description": {
            "description": "The description of the game provider. This text does not follow HTML or Markdown, so newlines may need to be handled explicitly.",
            "type": [
              "string",
              "null"
            ]
          },
          "id": {
            "description": "The ID of the game provider.",
            "$ref": "#/components/schemas/GameProviderId"
          },
          "image_url": {
            "description": "The URL to the image of the game provider.",
            "type": "string"
          },
          "name": {
            "description": "The name of the game provider. Do not use this in URLs, as it may contain special characters.",
            "type": "string"
          },
          "slug": {
            "description": "The slug of the game provider. This may be used in URLs.",
            "type": "string"
          }
        }
      },
      "GameRating": {
        "type": "string",
        "enum": [
          "like",
          "dislike"
        ]
      },
      "GameRatingsResponse": {
        "type": "object",
        "required": [
          "dislikes",
          "likes"
        ],
        "properties": {
          "dislikes": {
            "description": "The number of dislikes the game has received.",
            "type": "integer",
            "format": "int64"
          },
          "likes": {
            "description": "The number of likes the game has received.",
            "type": "integer",
            "format": "int64"
          },
          "own_rating": {
            "description": "The rating the current user has given the game. If the user has not rated the game, this field is `null`. If the user Is not authenticated, this field is also `null`.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/GameRating"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "GameResponse": {
        "type": "object",
        "required": [
          "created_at",
          "devices",
          "id",
          "image_url",
          "is_hd",
          "name",
          "slug"
        ],
        "properties": {
          "created_at": {
            "description": "The date and time the game was created.",
            "type": "string",
            "format": "date-time"
          },
          "description": {
            "description": "The description of the game. This text does not follow HTML or Markdown, so newlines may need to be handled explicitly.",
            "type": [
              "string",
              "null"
            ]
          },
          "devices": {
            "description": "The devices the game is available on.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Device"
            }
          },
          "id": {
            "description": "The ID of the game.",
            "$ref": "#/components/schemas/GameId"
          },
          "image_url": {
            "description": "The URL to the image of the game.",
            "type": "string"
          },
          "is_hd": {
            "description": "Whether the game is available in HD.",
            "type": "boolean"
          },
          "metadata": {
            "description": "Additional metadata about the game. This is used to store arbitrary unstructured data and can thus not be relied upon to return a specific data.",
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": true
          },
          "name": {
            "description": "The name of the game. Do not use this in URLs, as it may contain special characters.",
            "type": "string"
          },
          "recalled_at": {
            "description": "The date the game was recalled. If the game has been recalled, this field contains the date of the recall. Recalled games are not available to play.",
            "type": [
              "string",
              "null"
            ],
            "format": "date"
          },
          "released_at": {
            "description": "The date the game was released. If the game has not been released yet, this field is `null`. Unreleased games are not available to play.",
            "type": [
              "string",
              "null"
            ],
            "format": "date"
          },
          "slug": {
            "description": "The slug of the game. This may be used in URLs.",
            "type": "string"
          }
        }
      },
      "GameRoundActionId": {
        "type": "integer",
        "format": "int64"
      },
      "Gender": {
        "type": "string",
        "enum": [
          "male",
          "female",
          "other"
        ]
      },
      "GetPaymentMethodsQuery": {
        "type": "object",
        "required": [
          "currency"
        ],
        "properties": {
          "currency": {
            "description": "The currency to get the payment methods for.",
            "$ref": "#/components/schemas/Currency"
          }
        }
      },
      "InitializePasswordResetRequest": {
        "examples": [
          {
            "email": "john@doe.com"
          }
        ],
        "type": "object",
        "required": [
          "email"
        ],
        "properties": {
          "email": {
            "description": "The email address of the user to reset the password for.",
            "type": "string",
            "format": "email"
          }
        }
      },
      "InternalError": {
        "type": "string"
      },
      "KycAccessTokenResponse": {
        "type": "object",
        "required": [
          "provider_identifier",
          "token",
          "user_id",
          "user_metadata"
        ],
        "properties": {
          "provider_identifier": {
            "description": "KYC provider identifier. This should be used to differentiate which WebSDK/flow to use.",
            "$ref": "#/components/schemas/KycProviderIdentifier"
          },
          "token": {
            "description": "Access token provided by the KYC integration",
            "type": "string"
          },
          "user_id": {
            "description": "User ID, this is the current user, and should never deviate from the current user",
            "$ref": "#/components/schemas/UserId"
          },
          "user_metadata": {
            "description": "User metadata that can be used to pre-fill KYC information",
            "$ref": "#/components/schemas/KycAccessTokenUserMetadataResponse"
          }
        }
      },
      "KycAccessTokenUserMetadataResponse": {
        "description": "Metadata that can be used to pre-fill KYC information.",
        "type": "object",
        "required": [
          "country_alpha2",
          "email",
          "language",
          "phone_number"
        ],
        "properties": {
          "country_alpha2": {
            "description": "User's jurisdiction country code in ISO 3166-1 alpha-2 format",
            "type": "string"
          },
          "email": {
            "description": "The user's email",
            "type": "string"
          },
          "language": {
            "description": "User's language in ISO 639-1 format",
            "type": "string"
          },
          "phone_number": {
            "description": "The user's phone number in E.164 format",
            "type": "string"
          }
        }
      },
      "KycProviderIdentifier": {
        "type": "string",
        "enum": [
          "sumsub"
        ]
      },
      "KycStatusResponse": {
        "type": "object",
        "required": [
          "has_active_kyc"
        ],
        "properties": {
          "has_active_kyc": {
            "description": "Whether the user has an active KYC and thus does not need to go through the KYC process again.",
            "type": "boolean"
          }
        }
      },
      "LeaseTokenResponse": {
        "type": "object",
        "required": [
          "token"
        ],
        "properties": {
          "token": {
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "LicenseId": {
        "type": "integer",
        "format": "int64"
      },
      "LicenseResponse": {
        "type": "object",
        "required": [
          "id",
          "name",
          "root_jurisdiction"
        ],
        "properties": {
          "id": {
            "description": "The ID of the license.",
            "$ref": "#/components/schemas/LicenseId"
          },
          "name": {
            "description": "The name of the license.",
            "type": "string"
          },
          "root_jurisdiction": {
            "description": "The root jurisdiction of the license. While licenses can cover multiple jurisdictions, this is the jurisdiction that the license is rooted in. Examples include Curacao, Anjouan, etc.",
            "$ref": "#/components/schemas/Country"
          }
        }
      },
      "ListGameActionsQuery": {
        "type": "object",
        "properties": {
          "action_type": {
            "description": "The type of the game action to filter by. If not set, all game actions (bet, win, etc.) will be included.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListGameActionsTypeQuery"
              },
              {
                "type": "null"
              }
            ]
          },
          "game_id": {
            "description": "Game ID to filter the game actions by. If not set, all game actions will be included.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/GameId"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "ListGameActionsTypeQuery": {
        "type": "string",
        "enum": [
          "bet",
          "win"
        ]
      },
      "ListNotificationsQuery": {
        "type": "object",
        "properties": {
          "read_status": {
            "description": "The read status of the notifications to filter by.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReadStatus"
              },
              {
                "type": "null"
              }
            ]
          },
          "types": {
            "description": "The types of the notifications to filter by.",
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/NotificationTypeDiscriminants"
            }
          }
        }
      },
      "ListPaymentFlowsQuery": {
        "type": "object",
        "properties": {
          "payment_type": {
            "description": "The payment type to filter the payment flows by. If not set, all payment types will be included.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaymentType"
              },
              {
                "type": "null"
              }
            ]
          },
          "wallet_id": {
            "description": "The wallet ID to filter the payment flows by. If not set, all wallets of the user will be included.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/WalletId"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "LoginRequest": {
        "examples": [
          {
            "next": null,
            "password": "test",
            "username": "john@doe.com"
          }
        ],
        "type": "object",
        "required": [
          "password",
          "username"
        ],
        "properties": {
          "next": {
            "description": "The URL to redirect to after login. If not set a 200 OK response is returned.",
            "type": [
              "string",
              "null"
            ],
            "format": "uri"
          },
          "password": {
            "description": "The password of the user.",
            "type": "string",
            "minLength": 1
          },
          "username": {
            "description": "The email address of the user.",
            "type": "string",
            "format": "email"
          }
        }
      },
      "Maybe_Boolean": {
        "type": [
          "boolean",
          "null"
        ]
      },
      "Maybe_PixKeyTypeDiscriminants": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/PixKeyTypeDiscriminants"
          },
          {
            "type": "null"
          }
        ]
      },
      "Maybe_String": {
        "type": [
          "string",
          "null"
        ]
      },
      "NotificationId": {
        "type": "integer",
        "format": "int64"
      },
      "NotificationParams": {
        "type": "object",
        "required": [
          "notification_id"
        ],
        "properties": {
          "notification_id": {
            "description": "The ID of the notification to retrieve.",
            "$ref": "#/components/schemas/NotificationId"
          }
        }
      },
      "NotificationResponse": {
        "type": "object",
        "required": [
          "created_at",
          "data",
          "id"
        ],
        "properties": {
          "created_at": {
            "description": "The time the notification was created.",
            "type": "string",
            "format": "date-time"
          },
          "data": {
            "description": "The data of the notification.",
            "$ref": "#/components/schemas/NotificationType"
          },
          "id": {
            "description": "The ID of the notification.",
            "$ref": "#/components/schemas/NotificationId"
          },
          "read_at": {
            "description": "The time the notification was read. If `null` the notification has not been read.",
            "type": [
              "string",
              "null"
            ],
            "format": "date-time"
          }
        }
      },
      "NotificationType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "data",
              "type"
            ],
            "properties": {
              "data": {
                "type": "object",
                "required": [
                  "flow_id",
                  "status"
                ],
                "properties": {
                  "flow_id": {
                    "$ref": "#/components/schemas/PaymentFlowId"
                  },
                  "status": {
                    "$ref": "#/components/schemas/PaymentStatus"
                  }
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "payment_status_update"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kyc_completed"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "data",
              "type"
            ],
            "properties": {
              "data": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "custom"
                ]
              }
            }
          }
        ]
      },
      "NotificationTypeDiscriminants": {
        "description": "Auto-generated discriminant enum variants",
        "type": "string",
        "enum": [
          "payment_status_update",
          "kyc_completed",
          "custom"
        ]
      },
      "PaginatorMetadata_for_ListGameActionsQuery": {
        "type": "object",
        "required": [
          "pagination"
        ],
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListGameActionsQuery"
              },
              {
                "type": "null"
              }
            ]
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginatorPosition"
          }
        }
      },
      "PaginatorMetadata_for_ListNotificationsQuery": {
        "type": "object",
        "required": [
          "pagination"
        ],
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListNotificationsQuery"
              },
              {
                "type": "null"
              }
            ]
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginatorPosition"
          }
        }
      },
      "PaginatorMetadata_for_ListPaymentFlowsQuery": {
        "type": "object",
        "required": [
          "pagination"
        ],
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListPaymentFlowsQuery"
              },
              {
                "type": "null"
              }
            ]
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginatorPosition"
          }
        }
      },
      "PaginatorMetadata_for_SearchGameProviderQuery": {
        "type": "object",
        "required": [
          "pagination"
        ],
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchGameProviderQuery"
              },
              {
                "type": "null"
              }
            ]
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginatorPosition"
          }
        }
      },
      "PaginatorMetadata_for_SearchGameQuery": {
        "type": "object",
        "required": [
          "pagination"
        ],
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchGameQuery"
              },
              {
                "type": "null"
              }
            ]
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginatorPosition"
          }
        }
      },
      "PaginatorPosition": {
        "type": "object",
        "required": [
          "total_items"
        ],
        "properties": {
          "limit": {
            "default": 20,
            "type": "integer",
            "format": "uint",
            "maximum": 100.0,
            "minimum": 1.0
          },
          "offset": {
            "default": 0,
            "type": "integer",
            "format": "uint",
            "minimum": 0.0
          },
          "total_items": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "PaginatorResponse_for_GameActionResponse_and_ListGameActionsQuery": {
        "type": "object",
        "required": [
          "data",
          "metadata"
        ],
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GameActionResponse"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginatorMetadata_for_ListGameActionsQuery"
          }
        }
      },
      "PaginatorResponse_for_NotificationResponse_and_ListNotificationsQuery": {
        "type": "object",
        "required": [
          "data",
          "metadata"
        ],
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationResponse"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginatorMetadata_for_ListNotificationsQuery"
          }
        }
      },
      "PaginatorResponse_for_PaymentFlowResponse_and_ListPaymentFlowsQuery": {
        "type": "object",
        "required": [
          "data",
          "metadata"
        ],
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PaymentFlowResponse"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginatorMetadata_for_ListPaymentFlowsQuery"
          }
        }
      },
      "PaginatorResponse_for_SearchGameProviderResponse_and_SearchGameProviderQuery": {
        "type": "object",
        "required": [
          "data",
          "metadata"
        ],
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchGameProviderResponse"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginatorMetadata_for_SearchGameProviderQuery"
          }
        }
      },
      "PaginatorResponse_for_SearchGameResponse_and_SearchGameQuery": {
        "type": "object",
        "required": [
          "data",
          "metadata"
        ],
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchGameResponse"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginatorMetadata_for_SearchGameQuery"
          }
        }
      },
      "PaginatorSelection": {
        "type": "object",
        "properties": {
          "limit": {
            "default": 20,
            "type": "integer",
            "format": "uint",
            "maximum": 100.0,
            "minimum": 1.0
          },
          "offset": {
            "default": 0,
            "type": "integer",
            "format": "uint",
            "minimum": 0.0
          }
        }
      },
      "PatchSignupFlowRequest": {
        "type": "object",
        "additionalProperties": true
      },
      "PatchUserAddressRequest": {
        "type": "object",
        "required": [
          "address_lines",
          "country"
        ],
        "properties": {
          "address_lines": {
            "description": "The address of the user.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "administrative_area": {
            "description": "The administrative area of the user, such as the state or province.",
            "type": [
              "string",
              "null"
            ]
          },
          "country": {
            "description": "The country of the user.",
            "$ref": "#/components/schemas/Country"
          },
          "formatted_address": {
            "description": "The formatted address of the user. Only use this if the address can not be represented by the other fields.",
            "type": [
              "string",
              "null"
            ]
          },
          "locality": {
            "description": "The city or town of the user.",
            "type": [
              "string",
              "null"
            ]
          },
          "postal_code": {
            "description": "The postal code of the user.",
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "PatchUserConsentSettingsRequest": {
        "type": "object",
        "properties": {
          "email": {
            "$ref": "#/components/schemas/Maybe_Boolean"
          },
          "post_mail": {
            "$ref": "#/components/schemas/Maybe_Boolean"
          },
          "push_notification": {
            "$ref": "#/components/schemas/Maybe_Boolean"
          },
          "site_notification": {
            "$ref": "#/components/schemas/Maybe_Boolean"
          },
          "sms": {
            "$ref": "#/components/schemas/Maybe_Boolean"
          },
          "telephone": {
            "$ref": "#/components/schemas/Maybe_Boolean"
          }
        }
      },
      "PatchUserPasswordRequest": {
        "type": "object",
        "required": [
          "current_password",
          "new_password"
        ],
        "properties": {
          "current_password": {
            "description": "The current password of the user. This is required to ensure that the user is the one making the request.",
            "type": "string"
          },
          "new_password": {
            "description": "The new password of the user.",
            "type": "string",
            "maxLength": 256,
            "minLength": 6
          }
        }
      },
      "PatchUserPaymentSettingsRequest": {
        "type": "object",
        "properties": {
          "pix_key_email": {
            "format": "email",
            "$ref": "#/components/schemas/Maybe_String"
          },
          "pix_key_evp": {
            "maxLength": 128,
            "minLength": 6,
            "maxItems": 128,
            "minItems": 6,
            "$ref": "#/components/schemas/Maybe_String"
          },
          "pix_key_phone": {
            "maxLength": 20,
            "minLength": 6,
            "maxItems": 20,
            "minItems": 6,
            "$ref": "#/components/schemas/Maybe_String"
          },
          "pix_key_type": {
            "$ref": "#/components/schemas/Maybe_PixKeyTypeDiscriminants"
          }
        }
      },
      "PatchUserSettingsRequest": {
        "type": "object",
        "properties": {
          "consents": {
            "default": {
              "email": null,
              "post_mail": null,
              "push_notification": null,
              "site_notification": null,
              "sms": null,
              "telephone": null
            },
            "$ref": "#/components/schemas/PatchUserConsentSettingsRequest"
          },
          "locale": {
            "maxLength": 5,
            "minLength": 2,
            "maxItems": 5,
            "minItems": 2,
            "$ref": "#/components/schemas/Maybe_String"
          },
          "payment": {
            "default": {
              "pix_key_email": null,
              "pix_key_evp": null,
              "pix_key_phone": null,
              "pix_key_type": null
            },
            "$ref": "#/components/schemas/PatchUserPaymentSettingsRequest"
          },
          "time_zone": {
            "$ref": "#/components/schemas/Maybe_String"
          }
        }
      },
      "PaymentFlowId": {
        "type": "integer",
        "format": "int64"
      },
      "PaymentFlowParams": {
        "type": "object",
        "required": [
          "flow_id"
        ],
        "properties": {
          "flow_id": {
            "description": "The ID of the payment flow.",
            "$ref": "#/components/schemas/PaymentFlowId"
          }
        }
      },
      "PaymentFlowResponse": {
        "type": "object",
        "required": [
          "amount",
          "created_at",
          "currency",
          "id",
          "payment_method_id",
          "payment_type",
          "wallet_id"
        ],
        "properties": {
          "amount": {
            "description": "The amount of the payment flow.",
            "$ref": "#/components/schemas/SystemAmount"
          },
          "created_at": {
            "description": "The time the payment flow was created.",
            "type": "string",
            "format": "date-time"
          },
          "currency": {
            "description": "The currency of the payment flow.",
            "$ref": "#/components/schemas/Currency"
          },
          "id": {
            "description": "The ID of the payment flow.",
            "$ref": "#/components/schemas/PaymentFlowId"
          },
          "payment_method_id": {
            "description": "The payment method ID the payment flow is associated with.",
            "$ref": "#/components/schemas/PaymentMethodId"
          },
          "payment_type": {
            "description": "The type of the payment flow.",
            "$ref": "#/components/schemas/PaymentType"
          },
          "status": {
            "description": "The last status of the payment flow. If no status is set, the payment has been initialized but not yet processed by the system in any way.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaymentStatus"
              },
              {
                "type": "null"
              }
            ]
          },
          "status_updated_at": {
            "description": "The time the payment flo",
            "type": [
              "string",
              "null"
            ],
            "format": "date-time"
          },
          "wallet_id": {
            "description": "The wallet ID the payment flow is associated with.",
            "$ref": "#/components/schemas/WalletId"
          }
        }
      },
      "PaymentLimitBound": {
        "type": "string",
        "enum": [
          "min",
          "max"
        ]
      },
      "PaymentLimitsQuery": {
        "type": "object",
        "required": [
          "currency",
          "payment_method_id"
        ],
        "properties": {
          "currency": {
            "description": "The currency to get the payment limits for.",
            "$ref": "#/components/schemas/Currency"
          },
          "payment_method_id": {
            "description": "The payment method to get the payment limits for.",
            "$ref": "#/components/schemas/PaymentMethodId"
          }
        }
      },
      "PaymentLimitsResponse": {
        "type": "object",
        "required": [
          "timeframe_limits"
        ],
        "properties": {
          "deposit_cooldown": {
            "description": "The number of seconds a user has to wait between deposits.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/DurationSeconds"
              },
              {
                "type": "null"
              }
            ]
          },
          "deposit_max": {
            "description": "The maximum deposit amount. This already accounts for first time deposit limits.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SystemAmount"
              },
              {
                "type": "null"
              }
            ]
          },
          "deposit_min": {
            "description": "The minimum deposit amount. This already accounts for first time deposit limits.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SystemAmount"
              },
              {
                "type": "null"
              }
            ]
          },
          "timeframe_limits": {
            "description": "Timeframe limits enforce that a user does not exceed payment limits over a certain timeframe. This can be used to enforce daily, weekly, monthly limits, etc.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PaymentLimitsTimeframeResponse"
            }
          },
          "withdrawal_cooldown": {
            "description": "The number of seconds a user has to wait between withdrawals.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/DurationSeconds"
              },
              {
                "type": "null"
              }
            ]
          },
          "withdrawal_max": {
            "description": "The maximum withdrawal amount. This already accounts for first time withdrawal limits.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SystemAmount"
              },
              {
                "type": "null"
              }
            ]
          },
          "withdrawal_min": {
            "description": "The minimum withdrawal amount. This already accounts for first time withdrawal limits.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SystemAmount"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "PaymentLimitsTimeframeResponse": {
        "type": "object",
        "required": [
          "days"
        ],
        "properties": {
          "days": {
            "description": "The number of days the timeframe limit applies to.",
            "type": "integer",
            "format": "int64"
          },
          "deposit": {
            "description": "The deposit limit for the timeframe.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SystemAmount"
              },
              {
                "type": "null"
              }
            ]
          },
          "withdrawal": {
            "description": "The withdrawal limit for the timeframe.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SystemAmount"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "PaymentMethodId": {
        "type": "integer",
        "format": "int64"
      },
      "PaymentMethodIdentifier": {
        "type": "string",
        "enum": [
          "pix"
        ]
      },
      "PaymentMethodResponse": {
        "type": "object",
        "required": [
          "id",
          "identifier",
          "name",
          "payment_method_type"
        ],
        "properties": {
          "description": {
            "description": "A non-internationalized description of the payment method. This should not be used for display purposes, as it may not be localized. Handle i18n via custom translation through the identifier attribute.",
            "type": [
              "string",
              "null"
            ]
          },
          "id": {
            "description": "The ID of the payment method.",
            "$ref": "#/components/schemas/PaymentMethodId"
          },
          "identifier": {
            "description": "The identifier of the payment method. This is a unique identifier that can be used to reference the payment method.",
            "$ref": "#/components/schemas/PaymentMethodIdentifier"
          },
          "name": {
            "description": "The name of the payment method. Do not use this for identification purposes, as names may not be unique as there may be multiple payment methods with the same name but different countries or currencies.",
            "type": "string"
          },
          "payment_method_type": {
            "description": "The type of the payment method, which can be used to determine how the payment method can be used and how it may be displayed to the user.",
            "$ref": "#/components/schemas/PaymentMethodType"
          }
        }
      },
      "PaymentMethodType": {
        "oneOf": [
          {
            "description": "Includes credit cards, debit cards, and prepaid cards.",
            "type": "string",
            "enum": [
              "card"
            ]
          },
          {
            "description": "Bank transfers like ACH (USA), SEPA (Europe), SWIFT, etc.",
            "type": "string",
            "enum": [
              "bank_transfer"
            ]
          },
          {
            "description": "Automatic withdrawals from a customer's bank account.",
            "type": "string",
            "enum": [
              "direct_debit"
            ]
          },
          {
            "description": "Payments through bank redirects (e.g., iDEAL, Giropay).",
            "type": "string",
            "enum": [
              "bank_redirect"
            ]
          },
          {
            "description": "Digital wallets like PayPal, Apple Pay, Google Pay.",
            "type": "string",
            "enum": [
              "e_wallet"
            ]
          },
          {
            "description": "Mobile payments like Alipay, WeChat Pay, M-Pesa.",
            "type": "string",
            "enum": [
              "mobile_payment"
            ]
          },
          {
            "description": "Installment payment services (e.g., Klarna, Afterpay).",
            "type": "string",
            "enum": [
              "buy_now_pay_later"
            ]
          },
          {
            "description": "Cash on delivery and cash-based voucher systems.",
            "type": "string",
            "enum": [
              "cash_payment"
            ]
          },
          {
            "description": "Payments made with cryptocurrencies (e.g., Bitcoin).",
            "type": "string",
            "enum": [
              "cryptocurrency"
            ]
          },
          {
            "description": "Charges added to a user's mobile phone bill.",
            "type": "string",
            "enum": [
              "carrier_billing"
            ]
          },
          {
            "description": "Traditional check payments.",
            "type": "string",
            "enum": [
              "cheque"
            ]
          },
          {
            "description": "B2B payments where an invoice is issued and paid later.",
            "type": "string",
            "enum": [
              "invoice"
            ]
          },
          {
            "description": "Payments using loyalty points or reward programs.",
            "type": "string",
            "enum": [
              "loyalty_points"
            ]
          },
          {
            "description": "Gift cards, prepaid vouchers, and similar methods.",
            "type": "string",
            "enum": [
              "voucher"
            ]
          },
          {
            "description": "Payments made by scanning a QR code.",
            "type": "string",
            "enum": [
              "qr_code_payment"
            ]
          },
          {
            "description": "Contactless payments using NFC technology.",
            "type": "string",
            "enum": [
              "nfc_payment"
            ]
          },
          {
            "description": "Payments via money orders.",
            "type": "string",
            "enum": [
              "money_order"
            ]
          },
          {
            "description": "Regional payment methods such as Pix or Boleto",
            "type": "string",
            "enum": [
              "regional"
            ]
          }
        ]
      },
      "PaymentStatus": {
        "type": "string",
        "enum": [
          "pending",
          "waiting_for_approval",
          "approved",
          "processing",
          "completed",
          "failed",
          "cancelled",
          "rejected",
          "refunded"
        ]
      },
      "PaymentTransactionRequest": {
        "type": "object",
        "required": [
          "amount",
          "currency",
          "payment_method_id"
        ],
        "properties": {
          "amount": {
            "description": "The amount of the payment transaction.",
            "$ref": "#/components/schemas/SystemAmount"
          },
          "currency": {
            "description": "The currency of the payment transaction.",
            "$ref": "#/components/schemas/Currency"
          },
          "payment_method_id": {
            "description": "The payment method ID to use for the payment transaction.",
            "$ref": "#/components/schemas/PaymentMethodId"
          }
        }
      },
      "PaymentType": {
        "type": "string",
        "enum": [
          "deposit",
          "withdrawal"
        ]
      },
      "PhoneNumber": {
        "required": [
          "code",
          "national"
        ],
        "properties": {
          "carrier": {
            "type": "string",
            "maxLength": 20
          },
          "code": {
            "required": [
              "source",
              "value"
            ],
            "properties": {
              "source": {
                "type": "string",
                "enum": [
                  "plus",
                  "idd",
                  "number",
                  "default"
                ]
              },
              "value": {
                "type": "number",
                "multipleOf": 1.0
              }
            }
          },
          "extension": {
            "type": "string",
            "maxLength": 20
          },
          "national": {
            "required": [
              "value"
            ],
            "properties": {
              "value": {
                "type": "number",
                "multipleOf": 1.0
              }
            }
          }
        }
      },
      "PixKeyTypeDiscriminants": {
        "description": "Auto-generated discriminant enum variants",
        "type": "string",
        "enum": [
          "CPF",
          "EMAIL",
          "PHONE",
          "EVP"
        ]
      },
      "RateGameRequest": {
        "type": "object",
        "properties": {
          "rating": {
            "description": "The rating to set for the game. If `null` the rating for the current user is removed.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/GameRating"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "ReadStatus": {
        "type": "string",
        "enum": [
          "read",
          "unread"
        ]
      },
      "RtcEventPayload": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "event",
              "payload"
            ],
            "properties": {
              "event": {
                "type": "string",
                "enum": [
                  "notification"
                ]
              },
              "payload": {
                "$ref": "#/components/schemas/NotificationType"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "event",
              "payload"
            ],
            "properties": {
              "event": {
                "type": "string",
                "enum": [
                  "ticker"
                ]
              },
              "payload": {
                "$ref": "#/components/schemas/TickerType"
              }
            }
          }
        ]
      },
      "SearchGameProviderQuery": {
        "type": "object",
        "properties": {
          "query": {
            "description": "An organic search query to find game providers by. Searched fields include but are not limited to: name, description, slug...",
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "SearchGameProviderResponse": {
        "description": "The response to a game provider search request. It only contains a limited set of information about the provider. If more information is needed, the provider ID can be used to fetch the full provider details via the \"get provider\" endpoint.",
        "type": "object",
        "required": [
          "id",
          "image_url",
          "name",
          "slug"
        ],
        "properties": {
          "id": {
            "description": "The ID of the game provider.",
            "$ref": "#/components/schemas/GameProviderId"
          },
          "image_url": {
            "type": "string"
          },
          "name": {
            "description": "The name of the game provider. Do not use this in URLs, as it may contain special characters.",
            "type": "string"
          },
          "score": {
            "description": "The search score of the game provider.",
            "type": [
              "number",
              "null"
            ],
            "format": "double"
          },
          "slug": {
            "description": "The slug of the game provider. This may be used in URLs.",
            "type": "string"
          }
        }
      },
      "SearchGameQuery": {
        "type": "object",
        "properties": {
          "category": {
            "description": "The category identifier to filter games by. If set, only games in this category are returned. Note: this is not the category ID, but the identifier.",
            "type": [
              "string",
              "null"
            ]
          },
          "provider_id": {
            "description": "The provider to filter games by. If set, only games by this provider are returned.",
            "type": [
              "integer",
              "null"
            ],
            "format": "int64"
          },
          "query": {
            "description": "An organic search query to find games by. Searched fields include but are not limited to: name, description, provider name...",
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "SearchGameResponse": {
        "description": "The response to a game search request. It only contains a limited set of information about the game. If more information is needed, the game ID can be used to fetch the full game details via the \"get game\" endpoint.",
        "type": "object",
        "required": [
          "id",
          "image_url",
          "name",
          "provider",
          "slug"
        ],
        "properties": {
          "id": {
            "description": "The ID of the game.",
            "$ref": "#/components/schemas/GameId"
          },
          "image_url": {
            "description": "The URL to the image of the game.",
            "type": "string"
          },
          "name": {
            "description": "The name of the game. Do not use this in URLs, as it may contain special characters.",
            "type": "string"
          },
          "provider": {
            "description": "The provider of the game.",
            "$ref": "#/components/schemas/SearchGameProviderResponse"
          },
          "score": {
            "description": "The search score of the game.",
            "type": [
              "number",
              "null"
            ],
            "format": "double"
          },
          "slug": {
            "description": "The slug of the game. This may be used in URLs.",
            "type": "string"
          }
        }
      },
      "SelectWalletRequest": {
        "type": "object",
        "required": [
          "currency"
        ],
        "properties": {
          "currency": {
            "description": "The ID of the wallet to select.",
            "$ref": "#/components/schemas/Currency"
          }
        }
      },
      "ServerError": {
        "description": "Represents various errors that can occur during server operations.\n\nThis enum covers a wide range of error scenarios, from wallet-related issues to payment processing problems, user authentication errors, and more.",
        "oneOf": [
          {
            "title": "Wallet was not found",
            "description": "This error occurs when:\n\n- The wallet ID provided doesn't exist\n\n- The wallet belongs to a different user\n\n- The wallet has been deleted or deactivated\n\n**Resolution:** Double-check the wallet ID and ensure you're using the correct currency.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Pending payment flow",
            "description": "This error occurs when attempting to initiate a new payment flow while an existing one is still in progress. The existing flow must be completed by either:\n\n- Approving - Rejecting - Failing - Completing\n\n**Resolution:** Wait for the current flow to be processed or cancel it if possible.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_PENDING_FLOW"
                ]
              },
              "metadata": {
                "$ref": "#/components/schemas/PaymentType"
              }
            }
          },
          {
            "title": "Wallet Is Missing a Payment Method",
            "description": "This typically occurs when:\n\n- It's a new wallet that hasn't been used for deposits yet - The previously attached payment method has been removed or invalidated\n\n**Note:** A payment method is usually attached to the wallet on the first successful deposit. Subsequent deposits and withdrawals can only be made using the same payment method.\n\n**Resolution:** Make an initial deposit to link a payment method to the wallet.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_MISSING_PAYMENT_METHOD"
                ]
              }
            }
          },
          {
            "title": "Wallet Has Insufficient Funds",
            "description": "This error occurs when:\n\n- Attempting to withdraw more than the available balance - Trying to place a bet that exceeds the wallet balance\n\n**Resolution:** Deposit additional funds into the wallet before attempting the operation again.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_INSUFFICIENT_FUNDS"
                ]
              }
            }
          },
          {
            "title": "Wallet Has No Deposit",
            "description": "This error occurs when trying to withdraw or bet with a wallet that has never received any funds.\n\n**Resolution:** Make an initial deposit into the wallet before attempting withdrawals or bets.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_MISSING_DEPOSIT"
                ]
              }
            }
          },
          {
            "title": "Wallet Has Insufficient Wagers",
            "description": "This error is typically thrown when:\n\n- The user tries to withdraw more money than allowed by the anti-money laundering system - The wallet hasn't met the minimum wagering requirements for withdrawals\n\n**Resolution:** Place more wagers or bets before attempting to withdraw funds.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_INSUFFICIENT_WAGERS"
                ]
              }
            }
          },
          {
            "title": "Wallet Payment Cooldown",
            "description": "This error occurs when:\n\n- A user attempts to make multiple withdrawals within a short time frame - The cooldown period (usually 24 hours) hasn't elapsed since the last withdrawal\n\n**Purpose:** This ensures that users don't abuse the system by making multiple withdrawals in a short period to circumvent withdrawal limits or the anti-money laundering system.\n\n**Resolution:** Wait for the specified time before attempting another withdrawal.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "WALLET_PAYMENT_COOLDOWN"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "minutes_left"
                ],
                "properties": {
                  "minutes_left": {
                    "description": "Minutes left until the user is allowed to make another payment",
                    "type": "integer",
                    "format": "int64"
                  }
                }
              }
            }
          },
          {
            "title": "Payment Method Not Allowed",
            "description": "This can happen when:\n\n- The user tries to trigger a payment outside of the attached payment method - The user tries to use a payment method that is not allowed in their jurisdiction\n\n**Resolution:** Choose a different, allowed payment method for the operation.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_METHOD_NOT_ALLOWED"
                ]
              }
            }
          },
          {
            "title": "Payment Amount Outside Limits",
            "description": "This error occurs when:\n\n- The payment amount is below the minimum allowed - The payment amount is above the maximum allowed\n\n**Resolution:** Adjust the payment amount to be within the specified limits.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_AMOUNT_OUTSIDE_LIMITS"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "bound"
                ],
                "properties": {
                  "bound": {
                    "description": "The bound that is violated",
                    "$ref": "#/components/schemas/PaymentLimitBound"
                  },
                  "max": {
                    "description": "The maximum allowed payment amount",
                    "type": [
                      "string",
                      "null"
                    ],
                    "pattern": "^-?[0-9]+(\\.[0-9]+)?$"
                  },
                  "min": {
                    "description": "The minimum allowed payment amount",
                    "type": [
                      "string",
                      "null"
                    ],
                    "pattern": "^-?[0-9]+(\\.[0-9]+)?$"
                  }
                }
              }
            }
          },
          {
            "title": "Payment Amount Exceeds Timeframe Limits",
            "description": "This error occurs when:\n\n- A user attempts to make payments exceeding a certain amount in a specific timeframe - The limit may exist on a wallet or global currency level\n\n**Note:** A user can have multiple such timeframe limits, all of which are checked before a payment is allowed.\n\n**Resolution:** Wait for the timeframe to reset or make smaller payments spread over time.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_AMOUNT_EXCEEDS_TIMEFRAME_LIMITS"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "days",
                  "limit"
                ],
                "properties": {
                  "days": {
                    "description": "The number of past days the limit is enforced for",
                    "type": "integer",
                    "format": "int64"
                  },
                  "limit": {
                    "description": "The monetary limit that is not allowed to be exceeded",
                    "type": "string",
                    "pattern": "^-?[0-9]+(\\.[0-9]+)?$"
                  }
                }
              }
            }
          },
          {
            "title": "Payment Amount Out of Bounds",
            "description": "This error occurs when:\n\n- A user attempts to make a payment with a non-positive amount\n\n**Resolution:** Ensure the payment amount is a positive value.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_AMOUNT_OUT_OF_BOUNDS"
                ]
              }
            }
          },
          {
            "title": "Payment Flow Not Found",
            "description": "This usually means that:\n\n- The user is trying to use a flow that doesn't exist - The flow doesn't belong to them - The flow has expired or been completed\n\n**Resolution:** Initiate a new payment flow or check the flow ID.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_FLOW_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Payment Flow in Invalid State",
            "description": "This error occurs when: - The payment flow is in a state that doesn't allow the requested operation - The flow has already been processed or cancelled - The flow has expired\n\n**Resolution:** Check the current status of the payment flow before",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_FLOW_INVALID_STATE"
                ]
              }
            }
          },
          {
            "title": "Payment Flow Not Awaiting Approval",
            "description": "This error is usually thrown when:\n\n- An administrator tries to approve a flow that is not in the \"awaiting approval\" state - The flow has already been processed or cancelled\n\n**Resolution:** Check the current status of the payment flow before attempting approval.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_FLOW_NOT_AWAITING_APPROVAL"
                ]
              }
            }
          },
          {
            "title": "Payment Provider Not Found",
            "description": "This error occurs when:\n\n- The payment provider ID provided doesn't exist in the system - The payment provider has been removed or deactivated - We could not choose a payment provider for the payment operation\n\n**Resolution:** Verify the payment provider ID and ensure it's still active in the system.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_PROVIDER_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Payment Provider Not Available",
            "description": "This error occurs when:\n\n- There are no payment providers available for the requested operation - There are payment providers available, but are not enabled in the system\n\n**Resolution:** Ensure that the payment providers are enabled in the system and that the user operation is supported by the available payment providers.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "NO_PAYMENT_PROVIDER_AVAILABLE"
                ]
              }
            }
          },
          {
            "title": "Payment method Not Found",
            "description": "This error occurs when:\n\n- The payment method ID provided doesn't exist in the system - The payment method has been removed or deactivated - We could not choose a payment method for the payment operation\n\n**Resolution:** Verify the payment method ID and ensure it's still active in the system.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "PAYMENT_METHOD_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "KYC Provider Not Found",
            "description": "This error occurs when:\n\n- The KYC provider ID provided doesn't exist in the system - The KYC provider has been removed or deactivated - We could not choose a KYC provider for the KYC operation\n\n**Resolution:** Verify the KYC provider ID and ensure it's still active in the system.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "KYC_PROVIDER_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Search Index Not Found",
            "description": "This error occurs when:\n\n- The search index requested doesn't exist in the system - The requester doesn't have access to the specified search index\n\n**Resolution:** Verify the search index name and ensure the requester has the necessary permissions.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "SEARCH_INDEX_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "User Could Not Be Found",
            "description": "This error occurs when:\n\n- The user doesn't exist in the system - The user account has been disabled or deleted\n\n**Resolution:** Verify the user ID and ensure the account is active.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "User Is Missing a Required Payment Method Key Value",
            "description": "Payment methods may support multiple sub-accounts the user has with the method. As an example, PIX supports the following payment key types:\n\n- CPF (individual taxpayer registry) - CNPJ (corporate taxpayer registry) - Email - Bank-provided UUID\n\nThis error occurs when the user has not set up a Payment method key value for the specified type.\n\n**Resolution:** Add the required payment method key value for the specified type in the user's profile.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_MISSING_PAYMENT_METHOD_ACCOUNT_TYPE_IDENTIFIER"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "account_type",
                  "payment_method"
                ],
                "properties": {
                  "account_type": {
                    "type": "string"
                  },
                  "payment_method": {
                    "$ref": "#/components/schemas/PaymentMethodIdentifier"
                  }
                }
              }
            }
          },
          {
            "title": "User Is Missing a Document",
            "description": "This error occurs when:\n\n- The user attempts to interact with an API that requires a document - The user's profile does not have a document associated with it\n\n**Resolution:** Add a valid document to the user's profile.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_MISSING_DOCUMENT"
                ]
              }
            }
          },
          {
            "title": "User Has an Invalid document",
            "description": "This error occurs when:\n\n- The user attempts to interact with an API that requires a valid document - The document associated with the user's profile is not valid or properly formatted\n\n**Resolution:** Update the user's profile with a valid document.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_INVALID_DOCUMENT"
                ]
              }
            }
          },
          {
            "title": "User Address Missing",
            "description": "This error occurs when:\n\n- The user attempts to interact with API endpoints that require an address, such as payments\n\n**Resolution:** Add an address to the user's profile.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_ADDRESS_MISSING"
                ]
              }
            }
          },
          {
            "title": "User KYC required",
            "description": "This error occurs when:\n\n- The user does not yet have a KYC completion - The old KYC completion has expired\n\n**Resolution:** Complete the KYC process before proceeding, by completing the KYC flow.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_KYC_REQUIRED"
                ]
              }
            }
          },
          {
            "title": "User Is Excluded",
            "description": "This error occurs when: - The user has excluded themselves from the casino - The user has been excluded by the casino\n\n**Resolution:** The user must await the exclusion period to end before being able to access the casino again.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_EXCLUDED"
                ]
              }
            }
          },
          {
            "title": "User Is Blocked",
            "description": "This error occurs when: - The user has been blocked by the casino\n\n**Resolution:** The user must contact support to resolve the issue.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_BLOCKED"
                ]
              }
            }
          },
          {
            "title": "The Jurisdiction Is Not Supported",
            "description": "The jurisdiction from which the API is being accessed is not supported. This may be due to missing licenses or the jurisdiction not being enabled in the system.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "JURISDICTION_NOT_SUPPORTED_NO_ALTERNATIVE_SITE"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "jurisdiction"
                ],
                "properties": {
                  "jurisdiction": {
                    "description": "The violating jurisdiction.",
                    "$ref": "#/components/schemas/Country"
                  }
                }
              }
            }
          },
          {
            "title": "The Jurisdiction Is Not Supported, Alternative Site Available",
            "description": "The jurisdiction from which the API is being accessed is not supported, but an alternative site is available.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "JURISDICTION_NOT_SUPPORTED_ALTERNATIVE_SITE"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "alternative_site",
                  "jurisdiction"
                ],
                "properties": {
                  "alternative_site": {
                    "description": "Alternative site that the user may be redirected to",
                    "$ref": "#/components/schemas/AlternativeSite"
                  },
                  "jurisdiction": {
                    "description": "The violating jurisdiction.",
                    "$ref": "#/components/schemas/Country"
                  }
                }
              }
            }
          },
          {
            "title": "User Account Jurisdiction Mismatch",
            "description": "The request jurisdiction deviates from the user's signup jurisdiction. This can happen if the user uses a VPN or proxy to access the service, or just traveled abroad. While using a VPN is valid, and is allowed by our system, it's important that the user's request may only be processed if the user's signup jurisdiction and the request jurisdiction are covered by the same license. This ensures compliance with regulatory requirements, while still allowing users to access the service from different locations.\n\n**Important:** Compliance regulations usually forbid us from telling the user that their VPN or proxy is the reason for the error. Instead, we should inform them that their network configuration is not supported. This might serve as a hint to the user that they should disable or change their VPN or proxy.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "USER_ACCOUNT_JURISDICTION_MISMATCH"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "jurisdiction"
                ],
                "properties": {
                  "jurisdiction": {
                    "description": "The violating jurisdiction.",
                    "$ref": "#/components/schemas/Country"
                  }
                }
              }
            }
          },
          {
            "title": "The Jurisdiction Is Supported But Not Enabled",
            "description": "The jurisdiction is supported by the system but is not enabled. Supported by the system means that the system means that there is a license that covers the jurisdiction, but it is not enabled via the system jurisdiction whitelist.\n\n**Resolution:** Enable the jurisdiction in the system.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "JURISDICTION_SUPPORTED_BUT_NOT_ENABLED"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "jurisdiction"
                ],
                "properties": {
                  "jurisdiction": {
                    "description": "The jurisdiction that is supported but not enabled.",
                    "$ref": "#/components/schemas/Country"
                  }
                }
              }
            }
          },
          {
            "title": "Host Not Supported",
            "description": "The requested Site (identified via the `Host` header) is not set up in the system.\n\nThis error occurs when:\n\n- The API request is made to a hostname that is not recognized or configured in the system - The Site corresponding to the hostname has been deactivated or removed\n\n**Resolution:** Verify the correct hostname for the API request or contact support to set up the required Site.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "HOST_NOT_SUPPORTED"
                ]
              }
            }
          },
          {
            "title": "Game Not Found",
            "description": "The requested game was not found in the system.\n\nThis error occurs when:\n\n- The game ID provided doesn't exist in the system - The game has been removed or deactivated\n\n**Resolution:** Verify the game ID and ensure it's still active in the system.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Game Provider Not Reachable",
            "description": "The game provider or aggregator is not reachable.\n\nThis error occurs when:\n\n- The system cannot establish a connection with the game provider or aggregator - The game provider or aggregator service is down or experiencing issues\n\n**Resolution:** Try again later or contact support if the issue persists.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_PROVIDER_NOT_REACHABLE"
                ]
              }
            }
          },
          {
            "title": "Game Provider Not Found",
            "description": "The game provider was not found. This error occurs when: - The game provider ID provided doesn't exist in the system",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_PROVIDER_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Game Aggregator Game Provider Mapping Not Found",
            "description": "The game aggregator game provider mapping was not found. This error occurs when: - The game aggregator is not yet mapped to the game provider in the system",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_AGGREGATOR_PROVIDER_MAPPING_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Game Aggregator Not Supported",
            "description": "The game aggregator for the requested game is not supported by the system.\n\nThis error occurs when:\n\n- The system doesn't have integration with the required game aggregator - The aggregator support has been removed or is temporarily disabled\n\n**Resolution:** Choose a game from a supported aggregator or contact support for more information.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_AGGREGATOR_NOT_SUPPORTED"
                ]
              }
            }
          },
          {
            "title": "Game Aggregator Missing",
            "description": "This error may occur when: - A game aggregator is removed from our system, leaving orphaned games if no other aggregator publishes them",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_AGGREGATOR_MISSING"
                ]
              }
            }
          },
          {
            "title": "Game Aggregator Not Found",
            "description": "The game aggregator was not found. This error occurs when: - The game aggregator ID provided doesn't exist in the system",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_AGGREGATOR_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Game URL Invalid",
            "description": "The game URL returned by the game provider is invalid.\n\nThis error occurs when:\n\n- The game provider returns a malformed or non-existent URL - The game might have been removed or relocated by the provider\n\n**Resolution:** Try again or choose a different game. If the issue persists, contact support.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "GAME_URL_INVALID"
                ]
              }
            }
          },
          {
            "title": "Signup Flow Not Found",
            "description": "This error occurs when:\n\n- The signup flow has already been completed - The flow has expired and been garbage collected - The flow ID provided never existed\n\n**Resolution:** Start a new signup flow or verify the flow ID if you believe this is an error.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "SIGNUP_FLOW_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Signup With Invalid Profile",
            "description": "This error can occur due to various reasons:\n\n- The user is blacklisted - The user's profile is incomplete or invalid - The user is underage for the service - Other regulatory or compliance issues\n\n**Resolution:** Review the signup requirements and ensure all necessary information is provided and valid.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "SIGNUP_INVALID_PROFILE"
                ]
              }
            }
          },
          {
            "title": "Exchange Rate Not Found",
            "description": "The required exchange rate for the requested currency conversion could not be found.\n\nThis error occurs when:\n\n- The system doesn't have up-to-date exchange rate information for the requested currency pair - One or both of the currencies in the conversion are not supported\n\n**Resolution:** Try again later or use a different currency pair. If the issue persists, contact support.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "EXCHANGE_RATE_NOT_FOUND"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "from",
                  "to"
                ],
                "properties": {
                  "from": {
                    "$ref": "#/components/schemas/Currency"
                  },
                  "to": {
                    "$ref": "#/components/schemas/Currency"
                  }
                }
              }
            }
          },
          {
            "title": "Payload Signature Verification Failed",
            "description": "This error mainly occurs with integrations that send signed payloads. It can happen when:\n\n- The signature is missing or malformed - The signature doesn't match the payload content - The signing key used is invalid or has been revoked\n\n**Resolution:** Check the signature generation process and ensure the correct keys are being used.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "INVALID_SIGNATURE"
                ]
              }
            }
          },
          {
            "title": "Invalid Request",
            "description": "This error occurs when: - The request is missing required headers\n\n**Resolution:** Ensure the request includes all required headers",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "MISSING_HEADER"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "header"
                ],
                "properties": {
                  "header": {
                    "type": "string"
                  }
                }
              }
            }
          },
          {
            "title": "Invalid Payload Encoding",
            "description": "This error occurs when:\n\n- The payload is malformed or corrupted - The payload format doesn't match the expected format (e.g., invalid JSON) - The payload encoding is not recognized by the system\n\n**Resolution:** Verify the payload format and encoding, ensuring it matches the API specifications.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "INVALID_ENCODING"
                ]
              }
            }
          },
          {
            "title": "Missing Sec-WebSocket-Protocol Header",
            "description": "This error occurs when:\n\n- A client attempts to establish a WebSocket connection without providing the necessary protocol header - The header is malformed or contains unsupported protocols\n\n**Resolution:** Ensure the WebSocket connection request includes a valid `Sec-WebSocket-Protocol` header.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "MISSING_SEC_WEB_SOCKET_PROTOCOL"
                ]
              }
            }
          },
          {
            "title": "Invalid User Geolocation",
            "description": "This error occurs when:\n\n- A request that requires geolocation data (e.g., CF-IPCountry) is made without this information - The geolocation information is present but invalid or in an unsupported format\n\n**Resolution:** Ensure the request includes valid geolocation information, typically provided through specific headers.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "INVALID_USER_GEOLOCATION"
                ]
              }
            }
          },
          {
            "title": "Invalid Bot Header",
            "description": "This error occurs when: - A request sends a `X-Bot` header with an invalid value",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "INVALID_BOT_HEADER"
                ]
              }
            }
          },
          {
            "title": "Lease Not Found",
            "description": "The requested lease for establishing a WebSocket connection could not be found or has expired.\n\nLeases are used by the WebSocket system to create short-lived tickets that the user uses to establish a WebSocket connection. This error occurs when:\n\n- The lease ID provided doesn't exist - The lease has expired before the WebSocket connection was established - The lease has already been used and is no longer valid\n\n**Resolution:** Request a new lease and attempt to establish the WebSocket connection again.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "LEASE_NOT_FOUND"
                ]
              }
            }
          },
          {
            "title": "Validation Failed",
            "description": "This error occurs when:\n\n- The payload doesn't meet the required format or data constraints - Required fields are missing or contain invalid values - The payload violates business logic rules\n\n**Resolution:** Review the API documentation for the correct payload format and constraints. Adjust the payload accordingly.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "VALIDATION"
                ]
              },
              "metadata": {
                "$ref": "#/components/schemas/SystemValidationErrors"
              }
            }
          },
          {
            "title": "Invalid Content Type",
            "description": "This error occurs when: - The content type of the request is not supported\n\n**Resolution:** Ensure the content type of the request is supported",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "INVALID_CONTENT_TYPE"
                ]
              },
              "metadata": {
                "type": "object",
                "required": [
                  "expected"
                ],
                "properties": {
                  "expected": {
                    "description": "The content type that was expected",
                    "type": "string"
                  }
                }
              }
            }
          },
          {
            "title": "Unauthorized",
            "description": "This error occurs when:\n\n- The user is not authenticated - The user lacks the necessary permissions to access the resource - The authentication token has expired or is invalid\n\n**Resolution:** Ensure the user is properly authenticated and has the required permissions. If necessary, refresh the authentication token.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "UNAUTHORIZED"
                ]
              }
            }
          },
          {
            "title": "Forbidden",
            "description": "This error occurs when:\n\n- The user is not authenticated - The user lacks the necessary permissions to access the resource - The authentication token has expired or is invalid\n\n**Resolution:** Ensure the user is properly authenticated and has the required permissions. If necessary, refresh the authentication token.",
            "type": "object",
            "required": [
              "code"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "FORBIDDEN"
                ]
              }
            }
          },
          {
            "title": "Internal Error",
            "description": "This error should never be thrown under normal circumstances. If it occurs, it indicates a severe problem within the system.\n\nPossible causes include:\n\n- Unhandled exceptions in the server code - Database connection failures - Critical system resource exhaustion\n\n**Resolution:** Contact the system administrators or support team immediately. Provide them with any error codes or messages received.",
            "type": "object",
            "required": [
              "code",
              "metadata"
            ],
            "properties": {
              "code": {
                "type": "string",
                "enum": [
                  "INTERNAL"
                ]
              },
              "metadata": {
                "$ref": "#/components/schemas/InternalError"
              }
            }
          }
        ]
      },
      "SignupFlowParams": {
        "type": "object",
        "required": [
          "flow_id"
        ],
        "properties": {
          "flow_id": {
            "description": "The ID of the signup flow to retrieve.",
            "type": "string"
          }
        }
      },
      "SignupFlowResponse": {
        "type": "object",
        "required": [
          "created_at",
          "fields",
          "id",
          "jurisdiction"
        ],
        "properties": {
          "created_at": {
            "description": "The time the signup flow was created.",
            "type": "string",
            "format": "date-time"
          },
          "fields": {
            "description": "The fields of the signup flow.",
            "type": "object",
            "additionalProperties": true
          },
          "id": {
            "description": "The ID of the signup flow.",
            "type": "string"
          },
          "jurisdiction": {
            "description": "The jurisdiction of the signup flow. This field can not be changed once set. The user will be created in this jurisdiction and thus is subject to the laws of this jurisdiction. Changing a user jurisdiction after signup is not easily possible without additional verification, information and setup.",
            "$ref": "#/components/schemas/Country"
          }
        }
      },
      "SiteResponse": {
        "type": "object",
        "required": [
          "base_url",
          "name",
          "servable"
        ],
        "properties": {
          "base_url": {
            "description": "The base URL of the site. This may be used for redirects, links, etc.",
            "$ref": "#/components/schemas/Url"
          },
          "name": {
            "description": "The name of the site.",
            "type": "string"
          },
          "servable": {
            "description": "Whether the site is servable by the current instance. If `false` the site is not servable but is accessible by a different casino instance of the owning company.",
            "type": "boolean"
          }
        }
      },
      "SystemAmount": {
        "type": "number",
        "format": "float"
      },
      "SystemValidationError": {
        "type": "object",
        "required": [
          "code",
          "params"
        ],
        "properties": {
          "code": {
            "description": "The error code for the validation error. This may be a well-known code like `required` or a custom code that has to be handled individually.",
            "$ref": "#/components/schemas/SystemValidationErrorCode"
          },
          "message": {
            "description": "A human-readable message describing the validation error. This should not be used for i18n purposes, as the message is intended for developers and is only available in english.",
            "type": [
              "string",
              "null"
            ]
          },
          "params": {
            "description": "Additional parameters that are relevant to the specific validation error.",
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "SystemValidationErrorCode": {
        "oneOf": [
          {
            "description": "Returned when the provided JSON data is invalid or cannot be parsed into the expected format.",
            "type": "string",
            "enum": [
              "data_error"
            ]
          },
          {
            "description": "Returned when the provided JSON has syntax errors like missing brackets or invalid escaping.",
            "type": "string",
            "enum": [
              "syntax_error"
            ]
          },
          {
            "description": "Returned when system encounters errors reading from the JSON input.",
            "type": "string",
            "enum": [
              "io_error"
            ]
          },
          {
            "description": "Returned when a field's format doesn't match the expected pattern or structure.",
            "type": "string",
            "enum": [
              "malformed"
            ]
          },
          {
            "description": "Returned when the provided credit card number is invalid.",
            "type": "string",
            "enum": [
              "credit_card"
            ]
          },
          {
            "description": "Returned when a required substring is not found in a string field, or a required key is missing from a map.",
            "type": "string",
            "enum": [
              "contains"
            ]
          },
          {
            "description": "Returned when a forbidden substring is found in a string field, or a forbidden key is present in a map.",
            "type": "string",
            "enum": [
              "does_not_contain"
            ]
          },
          {
            "description": "Returned when the provided email address is invalid according to HTML5 validation rules.",
            "type": "string",
            "enum": [
              "email"
            ]
          },
          {
            "description": "Returned when the provided IP address is invalid.",
            "type": "string",
            "enum": [
              "ip"
            ]
          },
          {
            "description": "Returned when a string or collection's length does not meet the required constraints.",
            "type": "string",
            "enum": [
              "length"
            ]
          },
          {
            "description": "Returned when two fields that must have matching values don't match.",
            "type": "string",
            "enum": [
              "must_match"
            ]
          },
          {
            "description": "Returned when a string contains invalid UTF-8 control characters.",
            "type": "string",
            "enum": [
              "non_control_character"
            ]
          },
          {
            "description": "Returned when a numeric value falls outside the allowed range.",
            "type": "string",
            "enum": [
              "range"
            ]
          },
          {
            "description": "Returned when a string doesn't match the required pattern.",
            "type": "string",
            "enum": [
              "regex"
            ]
          },
          {
            "description": "Returned when a required field is missing or null.",
            "type": "string",
            "enum": [
              "required"
            ]
          },
          {
            "description": "Returned when the provided URL is invalid.",
            "type": "string",
            "enum": [
              "url"
            ]
          },
          {
            "description": "Returned when a custom validation rule fails. The string contains details about the specific validation failure.",
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SystemValidationErrors": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/SystemValidationErrorsKind"
        }
      },
      "SystemValidationErrorsKind": {
        "anyOf": [
          {
            "description": "Validation information for the object it is associated with.",
            "$ref": "#/components/schemas/SystemValidationErrors"
          },
          {
            "description": "Validation information coinciding with the index of the list it is associated with.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SystemValidationErrors"
            }
          },
          {
            "description": "A list of specific validation errors for the field it is associated with.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SystemValidationError"
            }
          }
        ]
      },
      "TickerGame": {
        "type": "object",
        "required": [
          "id",
          "image_url",
          "name",
          "slug"
        ],
        "properties": {
          "id": {
            "description": "The ID of the game.",
            "$ref": "#/components/schemas/GameId"
          },
          "image_url": {
            "description": "The URL to the image of the game.",
            "type": "string"
          },
          "name": {
            "description": "The name of the game. Do not use this in URLs, as it may contain special characters.",
            "type": "string"
          },
          "slug": {
            "description": "The slug of the game. This may be used in URLs.",
            "type": "string"
          }
        }
      },
      "TickerType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "data",
              "type"
            ],
            "properties": {
              "data": {
                "type": "object",
                "required": [
                  "amount",
                  "currency",
                  "game",
                  "user_nickname"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/components/schemas/SystemAmount"
                  },
                  "currency": {
                    "$ref": "#/components/schemas/Currency"
                  },
                  "game": {
                    "$ref": "#/components/schemas/TickerGame"
                  },
                  "user_nickname": {
                    "type": "string"
                  }
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "winning_now"
                ]
              }
            }
          }
        ]
      },
      "Url": {
        "type": "string",
        "format": "uri"
      },
      "UserBalanceResponse": {
        "type": "object",
        "required": [
          "balance",
          "currency",
          "wallet_id"
        ],
        "properties": {
          "balance": {
            "description": "The balance of the wallet.",
            "$ref": "#/components/schemas/SystemAmount"
          },
          "currency": {
            "description": "The currency of the wallet.",
            "$ref": "#/components/schemas/Currency"
          },
          "wallet_id": {
            "description": "The ID of the wallet that the balance is for.",
            "$ref": "#/components/schemas/WalletId"
          }
        }
      },
      "UserId": {
        "type": "integer",
        "format": "int64"
      },
      "UserPhysicalAddressResponse": {
        "type": "object",
        "required": [
          "address_lines",
          "country"
        ],
        "properties": {
          "address_lines": {
            "description": "The address lines, usually containing the street address.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "administrative_area": {
            "description": "The administrative area of the user, e.g. state or province.",
            "type": [
              "string",
              "null"
            ]
          },
          "country": {
            "description": "The country of the user.",
            "$ref": "#/components/schemas/Country"
          },
          "formatted_address": {
            "description": "The formatted address of the user. This will only be set if the address can not be represented by the other fields.",
            "type": [
              "string",
              "null"
            ]
          },
          "locality": {
            "description": "The locality of the user, e.g. city or town.",
            "type": [
              "string",
              "null"
            ]
          },
          "postal_code": {
            "description": "The postal code of the user.",
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      "UserResponse": {
        "type": "object",
        "required": [
          "birthdate",
          "documents",
          "email",
          "id",
          "jurisdiction",
          "locale",
          "name",
          "phone",
          "time_zone"
        ],
        "properties": {
          "address": {
            "description": "The physical address of the user.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/UserPhysicalAddressResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "birthdate": {
            "description": "The birthdate of the user.",
            "type": "string",
            "format": "date"
          },
          "documents": {
            "description": "User associated documents",
            "type": "object",
            "additionalProperties": true
          },
          "email": {
            "description": "The email of the user.",
            "type": "string"
          },
          "family_name": {
            "description": "The family name of the user. We have methods of deriving the family name should we only get a name from e.g. a KYC provider, but they may not be 100% reliable and thus the existence of this field can not be guaranteed.",
            "type": [
              "string",
              "null"
            ]
          },
          "gender": {
            "description": "The gender of the user.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/Gender"
              },
              {
                "type": "null"
              }
            ]
          },
          "id": {
            "description": "The ID of the user.",
            "$ref": "#/components/schemas/UserId"
          },
          "jurisdiction": {
            "description": "The jurisdiction of the user. This field can not be easily changed once set.",
            "$ref": "#/components/schemas/Country"
          },
          "locale": {
            "description": "The language of the user in ISO 639-1 format.",
            "type": "string"
          },
          "name": {
            "description": "The name of the user.",
            "type": "string"
          },
          "phone": {
            "description": "The phone number of the user.",
            "$ref": "#/components/schemas/PhoneNumber"
          },
          "time_zone": {
            "description": "The time zone of the user in IANA time zone format.",
            "type": "string"
          }
        }
      },
      "WalletId": {
        "type": "integer",
        "format": "int64"
      },
      "WebSocketChannel": {
        "type": "string",
        "enum": [
          "user",
          "newest_wins"
        ]
      },
      "WebsocketLeaseRequest": {
        "type": "object",
        "required": [
          "channel"
        ],
        "properties": {
          "channel": {
            "description": "The channel to subscribe to.",
            "$ref": "#/components/schemas/WebSocketChannel"
          }
        }
      },
      "WhoamiResponse": {
        "type": "object",
        "required": [
          "email",
          "id"
        ],
        "properties": {
          "email": {
            "description": "The email address of the currently authenticated user.",
            "type": "string"
          },
          "id": {
            "description": "The user ID of the currently authenticated user.",
            "$ref": "#/components/schemas/UserId"
          }
        }
      }
    }
  }
}
