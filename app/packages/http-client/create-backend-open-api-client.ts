import createClient, { type Middleware } from "openapi-fetch";
import type { paths } from "./girobet-backend-generated-http-client/openapi-typescript"; // generated by openapi-typescript
import { HttpBackendApiError } from "./http-backend-api-error";
import { ErrorFailedToFetch } from "./error-failed-to-fetch";
import { useCountryName } from "~/composables/countryName";
import type { CommonDependenciesI } from "~/dependency-injection/load-di";
import { EmitCommandOpenUserActionModalModal } from "~/modules/users/infra/ui/EmitCommandOpenUserActionModal";

const createMiddlewareJurisdictionErrorHandler: (commonDependencies: CommonDependenciesI) => Middleware = (commonDependencies: CommonDependenciesI) => {
  const emitOpenUserModal = new EmitCommandOpenUserActionModalModal(commonDependencies.asyncMessagePublisher);
  return {
    async onResponse({ response }) {
      /* If a CORS error happens, the response may be null or undefined */
      if (!response) {
        return;
      }

      if (response.ok || !response.headers.get("content-type")?.includes("application/json")) {
        return;
      }

      const currentHost = commonDependencies.requestContext.currentHost;
      const locale = commonDependencies.requestContext.locale;

      const jsonResponse: unknown = await response.clone().json();
      if (HttpBackendApiError.isJurisdictionError(jsonResponse)) {
        switch (jsonResponse.code) {
          case "JURISDICTION_NOT_SUPPORTED_NO_ALTERNATIVE_SITE":
            await emitOpenUserModal.handle({ modal: "restrict_license_no_alternative", data: {
              jurisdiction: jsonResponse.metadata.jurisdiction,
              currentHost,
              blockedCountry: useCountryName(jsonResponse.metadata.jurisdiction, locale) || jsonResponse.metadata.jurisdiction,
            } });
            return;

          case "JURISDICTION_NOT_SUPPORTED_ALTERNATIVE_SITE": {
            const allowedUrl = jsonResponse.metadata.alternative_site.domain.frontend ? `https://${jsonResponse.metadata.alternative_site.domain.frontend}` : null;
            if (!allowedUrl) {
              await emitOpenUserModal.handle({ modal: "restrict_license_no_alternative", data: {
                jurisdiction: jsonResponse.metadata.jurisdiction,
                currentHost,
                blockedCountry: useCountryName(jsonResponse.metadata.jurisdiction, locale) || jsonResponse.metadata.jurisdiction,
              } });
              return;
            }

            await emitOpenUserModal.handle({
              modal: "restrict_license_alternative",
              data: {
                jurisdiction: jsonResponse.metadata.jurisdiction,
                allowedUrl,
                currentHost,
                blockedCountry: useCountryName(jsonResponse.metadata.jurisdiction, locale) || jsonResponse.metadata.jurisdiction,
              },
            });
            return;
          }

          case "USER_ACCOUNT_JURISDICTION_MISMATCH":
            await emitOpenUserModal.handle({
              modal: "restrict_license_no_alternative",
              data: {
                jurisdiction: jsonResponse.metadata.jurisdiction,
                currentHost,
                blockedCountry: useCountryName(jsonResponse.metadata.jurisdiction, locale) || jsonResponse.metadata.jurisdiction,
              },
            });
            return;

          case "JURISDICTION_SUPPORTED_BUT_NOT_ENABLED":
            await emitOpenUserModal.handle({
              modal: "restrict_expanding",
              data: {
                jurisdiction: jsonResponse.metadata.jurisdiction,
                currentHost,
                blockedCountry: useCountryName(jsonResponse.metadata.jurisdiction, locale) || jsonResponse.metadata.jurisdiction,
              },
            });
            return;

          default:
            return;
        }
      }
    },
  };
};

const createMiddlewareCorsErrorHandler: () => Middleware = () => {
  return {
    onError({ error, request, id, params }) {
      if (error instanceof Error) {
        if (error.message.includes("Failed to fetch")) {
          return ErrorFailedToFetch.new(request.url, { request: { id, params } });
        }
      }
      return;
    },
  };
};

export const createBackendOpenApiClient = (clientOptions: { baseUrl: string }, commonDependencies: CommonDependenciesI) => {
  const client = createClient<paths>({ baseUrl: clientOptions.baseUrl, credentials: "include", headers: {
    "Content-Type": "application/json",
    "X-Forwarded-Host": commonDependencies.requestContext.headers?.host,
    ...commonDependencies.requestContext.headers,
  } });
  client.use(
    createMiddlewareJurisdictionErrorHandler(commonDependencies),
    createMiddlewareCorsErrorHandler(),
  );
  return client;
};
