/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth/whoami": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Whoami
         * @description The whoami endpoint returns some basic information about the currently logged in user.
         *     This is primarily used for verifying that the user is logged in.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["WhoamiResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description User login form.
         *     The response will set a cookie and redirect to the 'next' URL, if provided.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["LoginRequestBody"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description no content */
                302: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Logout
         * @description User logout, that will unset the login session cookie if naviaged to.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signup/flow": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Create Signup Flow
         * @description Create a new signup flow that can be incrementally patched and the submitted for completion.
         *     This endpoint requires the `CF-IPCountry` header to be set and to be a valid jurisdiction.
         *     This header is normally set by Cloudflare and is used to determine the jurisdiction of the user,
         *     buy you may also set it manually during development.
         *     Note that you may need to configure the CORS settings to allow the `CF-IPCountry` header to be sent.
         *
         *     The ID returned by the signup flow can be stored in the frontend URL or other storage
         *     to recover the signup flow if the user reloads the page or does other destructive actions.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["FlowCreateResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signup/flow/{flow_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Signup Flow
         * @description Get the specified signup flow and all the fields that have been added to it.
         *     Use this for recovering form data if the user reloads the page or does other destructive actions.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    flow_id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SignupFlow"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        /**
         * Submit Signup Flow
         * @description Submit the specified signup flow and create the user entry.
         *     This can fail if certain validation of fields and jurisdiction dependent information is unsuccessful.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    flow_id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Signup Flow
         * @description
         *     Patch the specified signup flow with additional information.
         *
         *     Example request body for brazilian users:
         *     ```
         *      {
         *     	"first_name": "John",
         *     	"last_name": "Doe",
         *     	"email": "john@doe.com",
         *     	"password": "test",
         *     	"CPF": "536.726.824-20"
         *     }
         *     ````
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    flow_id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["SignupPatchFlowRequestBody"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/payment/deposit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Deposit Flow
         * @description Create a new deposit flow.
         *         This flow will be active as long as we don't receive a
         *         confirmation from our payment providers, that a deposit has been completed.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PaymentTransactionRequestBody"];
                };
            };
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaymentMethodDepositResponsePayload"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/withdraw": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Withdrawal Flow
         * @description Create a withdrawal flow.
         *         This flow will be active as long as we don't receive a confirmation from our payment provider,
         *         that they have successfully withdrawn the desired amount into the user's bank account.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PaymentTransactionRequestBody"];
                };
            };
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaymentMethodDepositResponsePayload"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Payment Flows
         * @description List all payment flows for the currently logged in user.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaymentFlowResult"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/limits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Payment Limits
         * @description Get the payment limits for the currently logged in user.
         */
        get: {
            parameters: {
                query: {
                    currency: components["schemas"]["SystemCurrency"];
                    payment_method: components["schemas"]["PaymentMethod"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LimitOverrides"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/licenses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Matched Licenses
         * @description Get the available system licenses for the requested jurisdiction/site header combination.
         *             The licenses are ordered in their priority order,
         *             and thus the first license in the list is the most preferred one.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LicenseResponse"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/site": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Matched Site
         * @description The the matched site based on the host header.
         *             Use this to differentiate between different sites in a multi-site setup,
         *             allowing for different configurations, themes, etc.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SiteResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/preflight": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Preflight Check
         * @description This preflight endpoint should be the first endpoint
         *             to be called by the client or the SSR implementation.
         *             It is used to check if the user is able to access the
         *             host + jurisdiction combination. Should they not be allowed to access
         *             the site, the endpoint will return a `JURISDICTION_NOT_SUPPORTED` error,
         *             possibly containing a list of alternative sites that the user can access.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}/session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Create Game Session
         * @description Create a new game session by providing the game ID,
         *         as well as the currency with which the game should be played with,
         *         and the client type of the user.
         *         The response will redirect the user to the third party URL of the game provider.
         *         Please note that this request should be used in conjunction with an iframe,
         *         so that the user does not get redirected from the casino website.
         */
        get: {
            parameters: {
                query: {
                    client_type: components["schemas"]["SystemDevice"];
                    currency: components["schemas"]["SystemCurrency"];
                };
                header?: never;
                path: {
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                307: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Games
         * @description Search for games by providing a search query.
         */
        get: {
            parameters: {
                query?: {
                    category?: string | null;
                    query?: string | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_GameSearchResult_and_GameSearchQuery"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/category/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Available Game Categories
         * @description Get a list of all game categories available in the casino.
         *         This can be used to show a list of game categories to the user,
         *         so that they can choose which category they want to explore.
         *         There are two major types of categories, staic and dynamic.
         *         Static categories are predefined by the casino, while dynamic categories
         *         cover games based on user behavior and other factors.
         *         Dynamic categories are recalcuated periodically.
         */
        get: {
            parameters: {
                query?: {
                    group?: components["schemas"]["CategoryGroup"] | null;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GameCategory"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}/rating": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Rate Game
         * @description Rate a game by its ID.
         *         This can be used to allow users to rate games,
         *         so that other users can see the rating of the game.
         *         Sending a rating of null will remove the rating of the user.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["CreateGameRating"];
                };
            };
            responses: {
                /** @description no content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Game
         * @description Get a game by its ID. This can be used to show a more detailed view of a game,
         *         including its name, description,
         *         and other metadata, that might be required to display the game on the frontend.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Game"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}/image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Game Image
         * @description Get the image of a game by its ID.
         *         This can be used to show the image of a game to the user,
         *         so that they can see what the game looks like.
         */
        get: {
            parameters: {
                query?: {
                    variant?: components["schemas"]["GameImageVariant"];
                };
                header?: never;
                path: {
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notification/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Notifications
         * @description Get a list of all notifications for the current user.
         */
        get: {
            parameters: {
                query?: {
                    read_status?: components["schemas"]["ReadStatus"] | null;
                    types?: components["schemas"]["NotificationTypeDiscriminants"][] | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_Notification_and_NotificationListFilter"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notification/{notification_id}/read-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Notification Read Status
         * @description Mark a notification as read.
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    notification_id: components["schemas"]["NotificationId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ReadStatus"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/user/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Profile
         * @description Get the user profile of the currently logged in user.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UserAccount"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/balance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Balance
         * @description Get the balance of the currently logged in user.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["WalletBalance"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Settings
         * @description Get the settings of the currently logged in user.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UserSettings"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update User Settings
         * @description Update the settings of the currently logged in user.
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["UserSettings"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/ws/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Establish WebSocket Connection
         * @description This route is the entry point for WebSocket connections in our system.
         *
         *     ## Authentication
         *
         *     - Authentication is required for all WebSocket connections.
         *     - Use a lease token obtained from the lease handler endpoint.
         *
         *     ## Connection Process
         *
         *     1. Obtain a lease token from the lease handler endpoint.
         *     2. Connect to this endpoint using the WebSocket protocol.
         *     3. Set the `sec-websocket-protocol` header as follows:
         *
         *        ```text
         *        Authorization,<lease-token>
         *        ```
         *
         *     ## Example (JavaScript)
         *
         *     ```javascript
         *     const leaseToken = "your-lease-token";
         *     const socket = new WebSocket("wss://your-domain.com/ws", ["Authorization", leaseToken]);
         *     ```
         *
         *     ## Important Notes
         *
         *     - Lease tokens are valid for 60 seconds.
         *     - Ensure your client can handle reconnection if the lease expires.
         *     - The server may close the connection if authentication fails.
         *
         *     For detailed information on lease generation and management, refer to the main WebSocket authentication documentation found [here](#tag/websocket/GET/ws/lease).
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ws/lease": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Issue WebSocket Lease
         * @description This endpoint is used to generate authentication tokens (leases) for WebSocket connections in our system.
         *
         *     ## Lease Generation
         *
         *     1. Send a request to the lease issuer endpoint.
         *     2. Specify the channel for which you want a lease.
         *     3. The endpoint will return a lease token.
         *
         *     ## Lease Properties
         *
         *     - Leases are short-lived tokens, valid for 60 seconds from the time of generation.
         *     - Each lease is tied to a specific channel.
         *
         *     ## Usage
         *
         *     - Use the generated lease token when establishing a WebSocket connection.
         *     - For detailed information on how to use the lease token in a WebSocket connection, refer to the documentation found [here](#tag/websocket/GET/ws/).
         *
         *     ## Important Notes
         *
         *     - Always generate a new lease before attempting to establish a WebSocket connection.
         *     - Ensure your client handles lease expiration and reconnection scenarios.
         *
         *     For any issues or questions, please contact our support team.
         */
        get: {
            parameters: {
                query: {
                    channel: components["schemas"]["WebSocketChannel"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LeaseTokenResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @enum {string} */
        CategoryGroup: "home" | "game_page" | "inventory";
        CreateGameRating: {
            rating?: components["schemas"]["GameRating"] | null;
        };
        CreateGameSessionRequestQuery: {
            client_type: components["schemas"]["SystemDevice"];
            currency: components["schemas"]["SystemCurrency"];
        };
        /** Format: int64 */
        DurationSeconds: number;
        FlowCreateResponse: {
            flow_id: string;
        };
        Game: {
            /** Format: date-time */
            created_at: string;
            description?: string | null;
            devices: components["schemas"]["SystemDevice"][];
            id: components["schemas"]["GameId"];
            is_hd: boolean;
            jurisdiction_strategy: components["schemas"]["JurisdictionStrategyDiscriminants"];
            metadata: Record<string, never>;
            name: string;
            payout: string;
            /** Format: date */
            recalled_at?: string | null;
            /** Format: date */
            released_at?: string | null;
            slug: string;
            volatility: components["schemas"]["SystemGameVolatility"];
        };
        GameCategory: {
            id: components["schemas"]["GameCategoryId"];
            identifier: string;
        };
        /** Format: int64 */
        GameCategoryId: number;
        GameCategoryListFilter: {
            group?: components["schemas"]["CategoryGroup"] | null;
        };
        /** Format: int64 */
        GameId: number;
        /** @enum {string} */
        GameImageVariant: "extra_small" | "small" | "medium" | "large" | "background";
        GamePathParams: {
            game_id: components["schemas"]["GameId"];
        };
        /** Format: int64 */
        GameProviderId: number;
        /** @enum {string} */
        GameRating: "Like" | "Dislike";
        GameSearchQuery: {
            category?: string | null;
            query?: string | null;
        };
        GameSearchResult: {
            id: components["schemas"]["GameId"];
            name: string;
            provider: components["schemas"]["ProviderSearchResult"];
            slug: string;
        };
        GetGameImageQuery: {
            variant?: components["schemas"]["GameImageVariant"];
        };
        GetPaymentLimitsQuery: {
            currency: components["schemas"]["SystemCurrency"];
            payment_method: components["schemas"]["PaymentMethod"];
        };
        InternalError: string;
        Jurisdiction: {
            code: components["schemas"]["SystemCountry"];
            currencies: components["schemas"]["SystemCurrency"][];
            name: string;
        };
        /**
         * @description Auto-generated discriminant enum variants
         * @enum {string}
         */
        JurisdictionStrategyDiscriminants: "include" | "exclude";
        LeaseTokenResponse: {
            /** Format: uuid */
            token: string;
        };
        /** Format: int64 */
        LicenseId: number;
        LicenseResponse: {
            id: components["schemas"]["LicenseId"];
            name: string;
            root_jurisdiction: components["schemas"]["SystemCountry"];
        };
        LimitOverrides: {
            deposit_cooldown?: components["schemas"]["DurationSeconds"] | null;
            deposit_max?: string | null;
            deposit_max_first?: string | null;
            deposit_min?: string | null;
            deposit_min_first?: string | null;
            timeframe_limits: components["schemas"]["TimeframeLimit"][];
            withdrawal_cooldown?: components["schemas"]["DurationSeconds"] | null;
            withdrawal_max?: string | null;
            withdrawal_max_first?: string | null;
            withdrawal_min?: string | null;
            withdrawal_min_first?: string | null;
        };
        LoginRequestBody: {
            next?: string | null;
            password: string;
            username: string;
        };
        MaybeOperator: unknown;
        Notification: {
            /** Format: date-time */
            created_at: string;
            data: components["schemas"]["NotificationType"];
            id: components["schemas"]["NotificationId"];
            /** Format: date-time */
            read_at?: string | null;
        };
        /** Format: int64 */
        NotificationId: number;
        NotificationListFilter: {
            read_status?: components["schemas"]["ReadStatus"] | null;
            types?: components["schemas"]["NotificationTypeDiscriminants"][] | null;
        };
        NotificationType: {
            data: {
                flow_id: components["schemas"]["PaymentFlowId"];
                status: components["schemas"]["PaymentStatus"];
            };
            /** @enum {string} */
            type: "payment_status_update";
        } | {
            data: string;
            /** @enum {string} */
            type: "test_status";
        };
        /**
         * @description Auto-generated discriminant enum variants
         * @enum {string}
         */
        NotificationTypeDiscriminants: "payment_status_update" | "test_status";
        PaginatorMetadata_for_GameSearchQuery: {
            filters?: components["schemas"]["GameSearchQuery"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorMetadata_for_NotificationListFilter: {
            filters?: components["schemas"]["NotificationListFilter"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorPosition: {
            /**
             * Format: uint
             * @default 20
             */
            limit: number;
            /**
             * Format: uint
             * @default 0
             */
            offset: number;
            /** Format: int64 */
            total_items: number;
        };
        PaginatorResponse_for_GameSearchResult_and_GameSearchQuery: {
            data: components["schemas"]["GameSearchResult"][];
            metadata: components["schemas"]["PaginatorMetadata_for_GameSearchQuery"];
        };
        PaginatorResponse_for_Notification_and_NotificationListFilter: {
            data: components["schemas"]["Notification"][];
            metadata: components["schemas"]["PaginatorMetadata_for_NotificationListFilter"];
        };
        PaginatorSelection: {
            /**
             * Format: uint
             * @default 20
             */
            limit: number;
            /**
             * Format: uint
             * @default 0
             */
            offset: number;
        };
        PathParams: {
            flow_id: string;
        };
        PathParams2: {
            notification_id: components["schemas"]["NotificationId"];
        };
        /** Format: int64 */
        PaymentFlowId: number;
        PaymentFlowResult: {
            amount: string;
            /** Format: date-time */
            completed_at?: string | null;
            /** Format: date-time */
            created_at: string;
            currency: components["schemas"]["SystemCurrency"];
            id: components["schemas"]["PaymentFlowId"];
            identifier: string;
            payment_method: components["schemas"]["PaymentMethod"];
            payment_provider: components["schemas"]["PaymentProvider"];
            payment_type: components["schemas"]["PaymentType"];
            wallet_id: components["schemas"]["WalletId"];
        };
        /** @enum {string} */
        PaymentLimitBound: "min" | "max";
        /** @enum {string} */
        PaymentMethod: "pix";
        PaymentMethodDepositResponsePayload: {
            pix: {
                flow_id: string;
                url: string;
            };
        };
        /** @enum {string} */
        PaymentProvider: "paybrokers" | "starspay";
        /** @enum {string} */
        PaymentStatus: "pending" | "waiting_for_approval" | "approved" | "processing" | "completed" | "failed" | "cancelled" | "rejected" | "refunded";
        PaymentTransactionRequestBody: {
            amount: string;
            currency: components["schemas"]["SystemCurrency"];
            payment_method: components["schemas"]["PaymentMethod"];
        };
        /** @enum {string} */
        PaymentType: "deposit" | "withdrawal";
        ProviderSearchResult: {
            id: components["schemas"]["GameProviderId"];
            name: string;
            slug: string;
        };
        /** @enum {string} */
        ReadStatus: "read" | "unread";
        /** @description Represents various errors that can occur during server operations.
         *
         *     This enum covers a wide range of error scenarios, from wallet-related issues to payment processing problems, user authentication errors, and more. */
        ServerError: {
            /** @enum {string} */
            code: "WALLET_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "WALLET_PENDING_FLOW";
            metadata: components["schemas"]["PaymentType"];
        } | {
            /** @enum {string} */
            code: "WALLET_MISSING_PAYMENT_METHOD";
        } | {
            /** @enum {string} */
            code: "WALLET_INSUFFICIENT_FUNDS";
        } | {
            /** @enum {string} */
            code: "WALLET_MISSING_DEPOSIT";
        } | {
            /** @enum {string} */
            code: "WALLET_INSUFFICIENT_WAGERS";
        } | {
            /** @enum {string} */
            code: "WALLET_PAYMENT_COOLDOWN";
            metadata: {
                /**
                 * Format: int64
                 * @description Minutes left until the user is allowed to make another payment
                 */
                minutes_left: number;
            };
        } | {
            /** @enum {string} */
            code: "PAYMENT_METHOD_NOT_ALLOWED";
        } | {
            /** @enum {string} */
            code: "PAYMENT_AMOUNT_EXCEEDS_LIMITS";
            metadata: {
                /** @description If the payment exceeds the minimum or maximum limit bound */
                bound: components["schemas"]["PaymentLimitBound"];
                /** @description The maximum allowed payment amount */
                max?: string | null;
                /** @description The minimum allowed payment amount */
                min?: string | null;
            };
        } | {
            /** @enum {string} */
            code: "PAYMENT_AMOUNT_EXCEEDS_TIMEFRAME_LIMITS";
            metadata: {
                /**
                 * Format: int64
                 * @description The number of past days the limit is enforced for
                 */
                days: number;
                /** @description The monetary limit that is not allowed to be exceeded */
                limit: string;
            };
        } | {
            /** @enum {string} */
            code: "PAYMENT_AMOUNT_OUT_OF_BOUNDS";
        } | {
            /** @enum {string} */
            code: "PAYMENT_FLOW_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "PAYMENT_FLOW_NOT_AWAITING_APPROVAL";
        } | {
            /** @enum {string} */
            code: "SEARCH_INDEX_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "USER_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "USER_MISSING_PAYMENT_METHOD_ACCOUNT_TYPE_IDENTIFIER";
            metadata: {
                account_type: string;
                payment_method: components["schemas"]["PaymentMethod"];
            };
        } | {
            /** @enum {string} */
            code: "USER_MISSING_DOCUMENT";
        } | {
            /** @enum {string} */
            code: "USER_INVALID_DOCUMENT";
        } | {
            /** @enum {string} */
            code: "JURISDICTION_NOT_SUPPORTED";
            metadata: {
                /** @description The violating jurisdiction. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "JURISDICTION_NOT_SUPPORTED_ALTERNATIVE_SITE";
            metadata: {
                /** @description Alternative site that the user may be redirected to */
                alternative_site: components["schemas"]["SiteResponse"];
                /** @description The violating jurisdiction. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "JURISDICTION_NOT_SUPPORTED_NETWORK_CONFIGURATION";
            metadata: {
                /** @description The violating jurisdiction. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "HOST_NOT_SUPPORTED";
        } | {
            /** @enum {string} */
            code: "GAME_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_PROVIDER_NOT_REACHABLE";
        } | {
            /** @enum {string} */
            code: "GAME_PROVIDER_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_PROVIDER_MAPPING_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_NOT_SUPPORTED";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_MISSING";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_URL_INVALID";
        } | {
            /** @enum {string} */
            code: "SIGNUP_FLOW_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "SIGNUP_INVALID_PROFILE";
        } | {
            /** @enum {string} */
            code: "EXCHANGE_RATE_NOT_FOUND";
            metadata: {
                from: components["schemas"]["SystemCurrency"];
                to: components["schemas"]["SystemCurrency"];
            };
        } | {
            /** @enum {string} */
            code: "INVALID_SIGNATURE";
        } | {
            /** @enum {string} */
            code: "INVALID_ENCODING";
        } | {
            /** @enum {string} */
            code: "MISSING_SEC_WEB_SOCKET_PROTOCOL";
        } | {
            /** @enum {string} */
            code: "INVALID_USER_GEOLOCATION";
        } | {
            /** @enum {string} */
            code: "INVALID_BOT_HEADER";
        } | {
            /** @enum {string} */
            code: "LEASE_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "VALIDATION";
            metadata: components["schemas"]["SystemValidationErrors"];
        } | {
            /** @enum {string} */
            code: "UNAUTHORIZED";
        } | {
            /** @enum {string} */
            code: "INTERNAL";
            metadata: components["schemas"]["InternalError"];
        };
        SignupFlow: {
            /** Format: date-time */
            created_at: string;
            fields: {
                [key: string]: unknown;
            };
            id: string;
            jurisdiction: components["schemas"]["SystemCountry"];
        };
        SignupPatchFlowRequestBody: {
            [key: string]: unknown;
        };
        SiteResponse: {
            name: string;
            redirect_url: string;
            servable: boolean;
        };
        /**
         * @description A country represented by its ISO 3166-1 alpha-2 code.
         * @enum {unknown}
         */
        SystemCountry: "AF" | "AX" | "AL" | "DZ" | "AS" | "AD" | "AO" | "AI" | "AQ" | "AG" | "AR" | "AM" | "AW" | "AU" | "AT" | "AZ" | "BS" | "BH" | "BD" | "BB" | "BY" | "BE" | "BZ" | "BJ" | "BM" | "BT" | "BO" | "BQ" | "BA" | "BW" | "BV" | "BR" | "IO" | "BN" | "BG" | "BF" | "BI" | "CV" | "KH" | "CM" | "CA" | "KY" | "CF" | "TD" | "CL" | "CN" | "CX" | "CC" | "CO" | "KM" | "CG" | "CD" | "CK" | "CR" | "CI" | "HR" | "CU" | "CW" | "CY" | "CZ" | "DK" | "DJ" | "DM" | "DO" | "EC" | "EG" | "SV" | "GQ" | "ER" | "EE" | "SZ" | "ET" | "FK" | "FO" | "FJ" | "FI" | "FR" | "GF" | "PF" | "TF" | "GA" | "GM" | "GE" | "DE" | "GH" | "GI" | "GR" | "GL" | "GD" | "GP" | "GU" | "GT" | "GG" | "GN" | "GW" | "GY" | "HT" | "HM" | "VA" | "HN" | "HK" | "HU" | "IS" | "IN" | "ID" | "IR" | "IQ" | "IE" | "IM" | "IL" | "IT" | "JM" | "JP" | "JE" | "JO" | "KZ" | "KE" | "KI" | "KP" | "KR" | "KW" | "KG" | "LA" | "LV" | "LB" | "LS" | "LR" | "LY" | "LI" | "LT" | "LU" | "MO" | "MG" | "MW" | "MY" | "MV" | "ML" | "MT" | "MH" | "MQ" | "MR" | "MU" | "YT" | "MX" | "FM" | "MD" | "MC" | "MN" | "ME" | "MS" | "MA" | "MZ" | "MM" | "NA" | "NR" | "NP" | "NL" | "NC" | "NZ" | "NI" | "NE" | "NG" | "NU" | "NF" | "MK" | "MP" | "NO" | "OM" | "PK" | "PW" | "PS" | "PA" | "PG" | "PY" | "PE" | "PH" | "PN" | "PL" | "PT" | "PR" | "QA" | "RE" | "RO" | "RU" | "RW" | "BL" | "SH" | "KN" | "LC" | "MF" | "PM" | "VC" | "WS" | "SM" | "ST" | "SA" | "SN" | "RS" | "SC" | "SL" | "SG" | "SX" | "SK" | "SI" | "SB" | "SO" | "ZA" | "GS" | "SS" | "ES" | "LK" | "SD" | "SR" | "SJ" | "SE" | "CH" | "SY" | "TW" | "TJ" | "TZ" | "TH" | "TL" | "TG" | "TK" | "TO" | "TT" | "TN" | "TR" | "TM" | "TC" | "TV" | "UG" | "UA" | "AE" | "GB" | "US" | "UM" | "UY" | "UZ" | "VU" | "VE" | "VN" | "VG" | "VI" | "WF" | "EH" | "YE" | "ZM" | "ZW";
        /** @description ISO 4217 3-letter currency code or 3/4-letter crypto currency code */
        SystemCurrency: unknown;
        /** @enum {string} */
        SystemDevice: "mobile" | "desktop";
        /** @enum {string} */
        SystemGameVolatility: "none" | "very-low" | "low" | "medium-low" | "medium" | "medium-high" | "high" | "very-high" | "extreme";
        /** @enum {string} */
        SystemGender: "male" | "female" | "other";
        SystemPhoneNumber: {
            carrier?: string;
            code: {
                /** @enum {string} */
                source: "plus" | "idd" | "number" | "default";
                value: number;
            };
            extension?: string;
            national: {
                value: number;
            };
        };
        SystemValidationError: {
            code: string;
            message?: string | null;
            params: {
                [key: string]: unknown;
            };
        };
        SystemValidationErrors: {
            [key: string]: components["schemas"]["SystemValidationErrorsKind"];
        };
        SystemValidationErrorsKind: components["schemas"]["SystemValidationErrors"] | {
            [key: string]: components["schemas"]["SystemValidationErrors"];
        } | components["schemas"]["SystemValidationError"][];
        TimeframeLimit: {
            /** Format: int64 */
            days: number;
            deposit?: string | null;
            withdrawal?: string | null;
        };
        UserAccount: {
            attributes: {
                [key: string]: unknown;
            };
            /** Format: date */
            birthdate: string;
            /** Format: date-time */
            blocked_until?: string | null;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            deleted_at?: string | null;
            email: string;
            email_verified: boolean;
            /** Format: date-time */
            excluded_until?: string | null;
            family_name?: string | null;
            gender?: components["schemas"]["SystemGender"] | null;
            id: components["schemas"]["UserId"];
            jurisdiction: components["schemas"]["Jurisdiction"];
            language: string;
            name: string;
            phone: components["schemas"]["SystemPhoneNumber"];
            phone_verified: boolean;
            settings: {
                [key: string]: unknown;
            };
            time_zone: string;
            /** Format: date-time */
            updated_at: string;
        };
        /** Format: int64 */
        UserId: number;
        UserSettings: {
            language?: components["schemas"]["MaybeOperator"];
            pix_payment_key?: components["schemas"]["MaybeOperator"];
            primary_currency?: components["schemas"]["MaybeOperator"];
        };
        WalletBalance: {
            balance: string;
            currency: components["schemas"]["SystemCurrency"];
        };
        /** Format: int64 */
        WalletId: number;
        /** @enum {string} */
        WebSocketChannel: "user" | "newest_wins";
        WebsocketLeaseQuery: {
            channel: components["schemas"]["WebSocketChannel"];
        };
        WhoamiResponse: {
            email: string;
            id: components["schemas"]["UserId"];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
