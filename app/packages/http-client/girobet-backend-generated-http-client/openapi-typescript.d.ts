/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/auth/whoami": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Whoami
         * @description The whoami endpoint returns some basic information about the currently logged in user.
         *     This is primarily used for verifying that the user is logged in.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["WhoamiResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login
         * @description User login form.
         *     The response will set a cookie and redirect to the 'next' URL, if provided.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["LoginRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description no content */
                302: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Logout
         * @description User logout, that will unset the login session cookie if naviaged to.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/forgot-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Password reset request
         * @description This endpoint will take a user email and send out a password reset email to the user.
         *     The email will contain a link that the user can click on to reset their password. The link will be valid for 60 minutes.
         *     Note that this endpoint will always return a 200 status code, even if the email does not exist in the database.
         *     This is to prevent attackers from using this endpoint to determine if an email exists in the database.
         *     The endpoint will also always take the same amount of time to respond, regardless of whether the email exists in the database or not.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InitializePasswordResetRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/reset-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Password reset
         * @description This endpoint takes a password reset token and the newly chosen password from the user.
         *     The token is sent to the user's email when they request a password reset.
         *     If the token is valid, the user's password will be updated to the new password.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["FinalizePasswordResetRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signup/flow": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Create Signup Flow
         * @description Create a new signup flow that can be incrementally patched and the submitted for completion.
         *     This endpoint requires the `CF-IPCountry` header to be set and to be a valid jurisdiction.
         *     This header is normally set by Cloudflare and is used to determine the jurisdiction of the user,
         *     buy you may also set it manually during development.
         *     Note that you may need to configure the CORS settings to allow the `CF-IPCountry` header to be sent.
         *
         *     The ID returned by the signup flow can be stored in the frontend URL or other storage
         *     to recover the signup flow if the user reloads the page or does other destructive actions.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CreateSignupFlowResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/signup/flow/{flow_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Signup Flow
         * @description Get the specified signup flow and all the fields that have been added to it.
         *     Use this for recovering form data if the user reloads the page or does other destructive actions.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the signup flow to retrieve. */
                    flow_id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SignupFlowResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        /**
         * Submit Signup Flow
         * @description Submit the specified signup flow and create the user entry.
         *     This can fail if certain validation of fields and jurisdiction dependent information is unsuccessful.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the signup flow to retrieve. */
                    flow_id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Signup Flow
         * @description
         *     Patch the specified signup flow with additional information.
         *
         *     Example request body for brazilian users:
         *     ```
         *      {
         *     	"first_name": "John",
         *     	"last_name": "Doe",
         *     	"email": "john@doe.com",
         *     	"password": "test",
         *     	"CPF": "549.448.010-09"
         *     }
         *     ```
         *
         *     #### Testing CPFs that you can use to create a user
         *
         *     - 549.448.010-09
         *     - 653.358.910-50
         *     - 715.176.900-80
         *     - 395.677.760-32
         *     - 993.093.100-73
         *
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the signup flow to retrieve. */
                    flow_id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PatchSignupFlowRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/payment/deposit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Deposit Flow
         * @description Create a new deposit flow.
         *         This flow will be active as long as we don't receive a
         *         confirmation from our payment providers, that a deposit has been completed.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PaymentTransactionRequest"];
                };
            };
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CreateDepositFlowResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/withdraw": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Withdrawal Flow
         * @description Create a withdrawal flow.
         *         This flow will be active as long as we don't receive a confirmation from our payment provider,
         *         that they have successfully withdrawn the desired amount into the user's bank account.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PaymentTransactionRequest"];
                };
            };
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CreateWithdrawalFlowResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Payment Flows
         * @description List all payment flows for the currently logged in user.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The payment type to filter the payment flows by. If not set, all payment types will be included. */
                    payment_type?: components["schemas"]["PaymentType"] | null;
                    /** @description The wallet ID to filter the payment flows by. If not set, all wallets of the user will be included. */
                    wallet_id?: components["schemas"]["WalletId"] | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_PaymentFlowResponse_and_ListPaymentFlowsQuery"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/limits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Payment Limits
         * @description Get the payment limits for the currently logged in user.
         */
        get: {
            parameters: {
                query: {
                    /** @description The currency to get the payment limits for. */
                    currency: components["schemas"]["SystemCurrency"];
                    /** @description The payment method to get the payment limits for. */
                    payment_method_id: components["schemas"]["PaymentMethodId"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaymentLimitsResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/payment/methods": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Payment Methods
         * @description Get all payment methods that can be used by the the user for the given currency.
         */
        get: {
            parameters: {
                query: {
                    /** @description The currency to get the payment methods for. */
                    currency: components["schemas"]["SystemCurrency"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaymentMethodResponse"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/licenses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Matched Licenses
         * @description Get the available system licenses for the requested jurisdiction/site header combination.
         *             The licenses are ordered in their priority order,
         *             and thus the first license in the list is the most preferred one.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LicenseResponse"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/site": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Matched Site
         * @description The the matched site based on the host header.
         *             Use this to differentiate between different sites in a multi-site setup,
         *             allowing for different configurations, themes, etc.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SiteResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system/preflight": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Preflight Check
         * @description This preflight endpoint should be the first endpoint
         *             to be called by the client or the SSR implementation.
         *             It is used to check if the user is able to access the
         *             host + jurisdiction combination. Should they not be allowed to access
         *             the site, the endpoint will return a `JURISDICTION_NOT_SUPPORTED` error,
         *             possibly containing a list of alternative sites that the user can access.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game-provider/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Game Providers
         * @description Search for games providers by providing a search query.
         */
        get: {
            parameters: {
                query?: {
                    /** @description An organic search query to find game providers by. Searched fields include but are not limited to: name, description, slug... */
                    query?: string | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_SearchGameProviderResponse_and_SearchGameProviderQuery"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game-provider/{provider_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Game Provider
         * @description Get a game provider by its ID.
         *             This can be used to show a more detailed view of of the
         *             provider profile in the frontend, which may require more data than
         *             the search endpoint provides.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the game provider. */
                    provider_id: components["schemas"]["GameProviderId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GameProviderResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}/session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Create Game Session
         * @description Create a new game session by providing the game ID,
         *         as well as the currency with which the game should be played with,
         *         and the client type of the user.
         *         The response will redirect the user to the third party URL of the game provider.
         *         Please note that this request should be used in conjunction with an iframe,
         *         so that the user does not get redirected from the casino website.
         */
        get: {
            parameters: {
                query: {
                    /** @description The device type the game session is started on. Some games may only be available on certain devices. */
                    client_type: components["schemas"]["SystemDevice"];
                    /** @description The currency (wallet) to use for the game session. It can not be changed during the session. */
                    currency: components["schemas"]["SystemCurrency"];
                };
                header?: never;
                path: {
                    /** @description The ID of the game to retrieve. */
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description no content */
                307: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search Games
         * @description Search for games by providing a search query.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The category identifier to filter games by. If set, only games in this category are returned. Note: this is not the category ID, but the identifier. */
                    category?: string | null;
                    /** @description The provider to filter games by. If set, only games by this provider are returned. */
                    provider_id?: number | null;
                    /** @description An organic search query to find games by. Searched fields include but are not limited to: name, description, provider name... */
                    query?: string | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_SearchGameResponse_and_SearchGameQuery"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/action/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Game Actions
         * @description Get a list of all game actions of the user.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The type of the game action to filter by. If not set, all game actions (bet, win, etc.) will be included. */
                    action_type?: components["schemas"]["ListGameActionsTypeQuery"] | null;
                    /** @description Game ID to filter the game actions by. If not set, all game actions will be included. */
                    game_id?: components["schemas"]["GameId"] | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_GameActionResponse_and_ListGameActionsQuery"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/category/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Available Game Categories
         * @description Get a list of all game categories available in the casino.
         *         This can be used to show a list of game categories to the user,
         *         so that they can choose which category they want to explore.
         *         There are two major types of categories, staic and dynamic.
         *         Static categories are predefined by the casino, while dynamic categories
         *         cover games based on user behavior and other factors.
         *         Dynamic categories are recalcuated periodically.
         */
        get: {
            parameters: {
                query?: {
                    group?: components["schemas"]["CategoryGroup"] | null;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CategoryResponse"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}/rating": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Rate Game
         * @description Rate a game by its ID.
         *         This can be used to allow users to rate games,
         *         so that other users can see the rating of the game.
         *         Sending a rating of null will remove the rating of the user.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the game to retrieve. */
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["RateGameRequest"];
                };
            };
            responses: {
                /** @description no content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}/ratings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Game Ratings
         * @description User ratings split up into likes and dislikes
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the game to retrieve. */
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GameRatingsResponse"];
                    };
                };
                /** @description no content */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/game/{game_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Game
         * @description Get a game by its ID. This can be used to show a more detailed view of a game,
         *         including its name, description,
         *         and other metadata, that might be required to display the game on the frontend.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the game to retrieve. */
                    game_id: components["schemas"]["GameId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GameResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notification/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Notifications
         * @description Get a list of all notifications for the current user.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The read status of the notifications to filter by. */
                    read_status?: components["schemas"]["ReadStatus"] | null;
                    /** @description The types of the notifications to filter by. */
                    types?: components["schemas"]["NotificationTypeDiscriminants"][] | null;
                    limit?: number;
                    offset?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaginatorResponse_for_NotificationResponse_and_ListNotificationsQuery"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notification/{notification_id}/read-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Notification Read Status
         * @description Mark a notification as read.
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The ID of the notification to retrieve. */
                    notification_id: components["schemas"]["NotificationId"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ReadStatus"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/user/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Profile
         * @description Get the user profile of the currently logged in user.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UserResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/balance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Balance
         * @description Get the balance of the currently logged in user. The wallets are returned in the order of their selection. Frontends mays utilize this order to display the wallets, and to identify the active wallet.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UserBalanceResponse"][];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Settings
         * @description Get the settings of the currently logged in user.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PatchUserSettingsRequest"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update User Settings
         * @description Update the settings of the currently logged in user.
         *
         *     This endpoint allows for partial updates of the user settings, by
         *     only updating the fields that are provided in the request.
         *
         *     If a field is set to `null`, it will be reset to the default value.
         *
         *     If a field is not provided, it will not be updated.
         *
         *     Partial updates follow the [RFC 7396](https://datatracker.ietf.org/doc/html/rfc7396) JSON Merge Patch standard.
         *
         *     ```json
         *     // Given the following JSON
         *     {
         *     	"title": "Goodbye!",
         *     	"author" : {
         *     		"givenName" : "John",
         *     		"familyName" : "Doe"
         *     	},
         *     	"tags":[ "example", "sample" ],
         *     	"content": "This will be unchanged"
         *     }
         *
         *     // Merged with the following patch
         *     {
         *     	"title": "Hello!",
         *     	"phoneNumber": "+01-123-456-7890",
         *     	"author": {
         *     		"familyName": null
         *     	},
         *     	"tags": [ "example" ]
         *     }
         *
         *     // Will result in the following JSON
         *     {
         *     	"title": "Hello!",
         *     	"author" : {
         *     		"givenName" : "John"
         *     	},
         *     	"tags": [ "example" ],
         *     	"content": "This will be unchanged",
         *     	"phoneNumber": "+01-123-456-7890"
         *     }
         *     ```
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PatchUserSettingsRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/user/active-wallet": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update User Active Wallet
         * @description Update the selected wallet of the user. The user balance endpoint will return the user's wallets in the order of their selection time.
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["SelectWalletRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/user/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update User Password
         * @description Update the password of the currently logged in user. The current password is required to ensure that the user is authorized to change the password.
         */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["PatchUserPasswordRequest"];
                };
            };
            responses: {
                /** @description no content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/ws/lease": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Issue WebSocket Lease
         * @description This endpoint is used to generate authentication tokens (leases) for WebSocket connections in our system.
         *
         *     ## Lease Generation
         *
         *     1. Send a request to the lease issuer endpoint.
         *     2. Specify the channel for which you want a lease.
         *     3. The endpoint will return a lease token.
         *
         *     ## Lease Properties
         *
         *     - Leases are short-lived tokens, valid for 60 seconds from the time of generation.
         *     - Each lease is tied to a specific channel.
         *
         *     ## Usage
         *
         *     - Use the generated lease token when establishing a WebSocket connection.
         *     - For detailed information on how to use the lease token in a WebSocket connection, refer to the documentation found [here](#tag/websocket/GET/ws/connect).
         *
         *     ## Important Notes
         *
         *     - Always generate a new lease before attempting to establish a WebSocket connection.
         *     - Ensure your client handles lease expiration and reconnection scenarios.
         *
         *     For any issues or questions, please contact our support team.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["WebsocketLeaseRequest"];
                };
            };
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LeaseTokenResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kyc/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get KYC Access Token
         * @description This endpoint returns a temporary short-lived token that is bound to the user.
         *     It can be used in conjunction with a KYC provider's SDK to perform KYC validation in the frontend.
         *
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["KycAccessTokenResponse"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/docs/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description This documentation page. */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description HTML content */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/html": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ws/connect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Establish WebSocket Connection
         * @description This route is the entry point for WebSocket connections in our system.
         *
         *     ## Authentication
         *
         *     - Authentication is required for all WebSocket connections.
         *     - Use a lease token obtained from the lease handler endpoint.
         *
         *     ## Connection Process
         *
         *     1. Obtain a lease token from the lease handler endpoint.
         *     2. Connect to this endpoint using the WebSocket protocol.
         *     3. Set the `sec-websocket-protocol` header as follows:
         *
         *        ```text
         *        Authorization,<lease-token>
         *        ```
         *
         *     ## Example (JavaScript)
         *
         *     ```javascript
         *     const leaseToken = "your-lease-token";
         *     const socket = new WebSocket("wss://your-domain.com/ws/connect", ["Authorization", leaseToken]);
         *     ```
         *
         *     ## Important Notes
         *
         *     - Lease tokens are valid for 60 seconds.
         *     - Ensure your client can handle reconnection if the lease expires.
         *     - The server may close the connection if authentication fails.
         *
         *     For detailed information on lease generation and management, refer to the main WebSocket authentication documentation found [here](#tag/websocket/POST/ws/lease).
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["RtcEventPayload"];
                    };
                };
                "4XX": {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ServerError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AlternativeSite: {
            /** @description The base URL of the alternative site. This url should be used to redirect the user to the alternative site. The URL may include a path too, so this needs to be taken into account. */
            base_url: components["schemas"]["SystemUrl"];
            /** @description The name of the alternative site. */
            name: string;
            /** @description The field "servable" indicates if this site is able to be served by the current casino instance. If there's an alternative, which can not be served by the current casino instance, but can be served by another casino instance, this is false. Example scenario: Cross-regional deployments of this system, with independent databases require the ability to point to each other as alternatives, as they can't serve the requested site themselves. */
            servable: boolean;
        };
        /** @enum {string} */
        CategoryGroup: "home" | "game_page" | "inventory";
        CategoryResponse: {
            /** @description The ID of the game category. */
            id: components["schemas"]["GameCategoryId"];
            /** @description The identifier of the game category. This is a unique string that can be used to identify the category in the game search endpoint. */
            identifier: string;
        };
        CreateDepositFlowResponse: {
            /** @description Withdrawal payment flow ID */
            flow_id: components["schemas"]["PaymentFlowId"];
        } & {
            pix: {
                /** @description The PIX code used by the user for depositing the amount */
                code: string;
            };
        };
        CreateGameSessionQuery: {
            /** @description The device type the game session is started on. Some games may only be available on certain devices. */
            client_type: components["schemas"]["SystemDevice"];
            /** @description The currency (wallet) to use for the game session. It can not be changed during the session. */
            currency: components["schemas"]["SystemCurrency"];
        };
        CreateSignupFlowResponse: {
            /** @description The ID of the created signup flow. */
            flow_id: string;
        };
        CreateWithdrawalFlowResponse: {
            /** @description Withdrawal payment flow ID */
            flow_id: components["schemas"]["PaymentFlowId"];
        };
        /** Format: int64 */
        DurationSeconds: number;
        FinalizePasswordResetRequest: {
            /** @description The new password for the user. */
            password: string;
            /**
             * Format: uuid
             * @description The token that was sent to the user and has to be included for the reset to succeed.
             */
            token: string;
        };
        GameActionResponse: {
            /** @description The type of the action that was performed. Either Bets or Wins. */
            action: components["schemas"]["GameActionType"];
            /** @description The amount of the action. This is the amount that was bet, won, etc. */
            amount: components["schemas"]["SystemAmount"];
            /**
             * Format: date-time
             * @description The date and time the action was performed.
             */
            created_at: string;
            /** @description The currency the amount was in. */
            currency: components["schemas"]["SystemCurrency"];
            /** @description The ID of the game the action was performed on. */
            game_id: components["schemas"]["GameId"];
            /** @description The name of the game the action was performed on. */
            game_name: string;
            /** @description The ID of the game action. */
            id: components["schemas"]["GameRoundActionId"];
        };
        /** @enum {string} */
        GameActionType: "bet" | "win" | "rollback";
        /** Format: int64 */
        GameCategoryId: number;
        GameCategoryListFilter: {
            group?: components["schemas"]["CategoryGroup"] | null;
        };
        /** Format: int64 */
        GameId: number;
        GameParams: {
            /** @description The ID of the game to retrieve. */
            game_id: components["schemas"]["GameId"];
        };
        /** Format: int64 */
        GameProviderId: number;
        GameProviderParams: {
            /** @description The ID of the game provider. */
            provider_id: components["schemas"]["GameProviderId"];
        };
        /** @description The response to a game provider request. It contains all available information about the provider. */
        GameProviderResponse: {
            /** @description The description of the game provider. This text does not follow HTML or Markdown, so newlines may need to be handled explicitly. */
            description?: string | null;
            /** @description The ID of the game provider. */
            id: components["schemas"]["GameProviderId"];
            /** @description The URL to the image of the game provider. */
            image_url: string;
            /** @description The name of the game provider. Do not use this in URLs, as it may contain special characters. */
            name: string;
            /** @description The slug of the game provider. This may be used in URLs. */
            slug: string;
        };
        /** @enum {string} */
        GameRating: "like" | "dislike";
        GameRatingsResponse: {
            /**
             * Format: int64
             * @description The number of dislikes the game has received.
             */
            dislikes: number;
            /**
             * Format: int64
             * @description The number of likes the game has received.
             */
            likes: number;
            /** @description The rating the current user has given the game. If the user has not rated the game, this field is `null`. If the user Is not authenticated, this field is also `null`. */
            own_rating?: components["schemas"]["GameRating"] | null;
        };
        GameResponse: {
            /**
             * Format: date-time
             * @description The date and time the game was created.
             */
            created_at: string;
            /** @description The description of the game. This text does not follow HTML or Markdown, so newlines may need to be handled explicitly. */
            description?: string | null;
            /** @description The devices the game is available on. */
            devices: components["schemas"]["SystemDevice"][];
            /** @description The ID of the game. */
            id: components["schemas"]["GameId"];
            /** @description The URL to the image of the game. */
            image_url: string;
            /** @description Whether the game is available in HD. */
            is_hd: boolean;
            /** @description Additional metadata about the game. This is used to store arbitrary unstructured data and can thus not be relied upon to return a specific data. */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /** @description The name of the game. Do not use this in URLs, as it may contain special characters. */
            name: string;
            /**
             * Format: date
             * @description The date the game was recalled. If the game has been recalled, this field contains the date of the recall. Recalled games are not available to play.
             */
            recalled_at?: string | null;
            /**
             * Format: date
             * @description The date the game was released. If the game has not been released yet, this field is `null`. Unreleased games are not available to play.
             */
            released_at?: string | null;
            /** @description The slug of the game. This may be used in URLs. */
            slug: string;
        };
        /** Format: int64 */
        GameRoundActionId: number;
        GetPaymentMethodsQuery: {
            /** @description The currency to get the payment methods for. */
            currency: components["schemas"]["SystemCurrency"];
        };
        InitializePasswordResetRequest: {
            /** @description The email address of the user to reset the password for. */
            email: string;
        };
        InternalError: string;
        KycAccessTokenResponse: {
            /** @description KYC provider identifier. This should be used to differentiate which WebSDK/flow to use. */
            provider_identifier: components["schemas"]["KycProviderIdentifier"];
            /** @description Access token provided by the KYC integration */
            token: string;
            /** @description User ID, this is the current user, and should never deviate from the current user */
            user_id: components["schemas"]["UserId"];
            /** @description User metadata that can be used to pre-fill KYC information */
            user_metadata: components["schemas"]["KycAccessTokenUserMetadataResponse"];
        };
        /** @description Metadata that can be used to pre-fill KYC information. */
        KycAccessTokenUserMetadataResponse: {
            /** @description User's jurisdiction country code in ISO 3166-1 alpha-2 format */
            country_alpha2: string;
            /** @description The user's email */
            email: string;
            /** @description User's jurisdiction country code in ISO 3166-1 alpha-3 format User's language in ISO 639-1 format */
            language: string;
            /** @description The user's phone number in E.164 format */
            phone_number: string;
        };
        /** @enum {string} */
        KycProviderIdentifier: "sumsub";
        LeaseTokenResponse: {
            /** Format: uuid */
            token: string;
        };
        /** Format: int64 */
        LicenseId: number;
        LicenseResponse: {
            /** @description The ID of the license. */
            id: components["schemas"]["LicenseId"];
            /** @description The name of the license. */
            name: string;
            /** @description The root jurisdiction of the license. While licenses can cover multiple jurisdictions, this is the jurisdiction that the license is rooted in. Examples include Curacao, Anjouan, etc. */
            root_jurisdiction: components["schemas"]["SystemCountry"];
        };
        ListGameActionsQuery: {
            /** @description The type of the game action to filter by. If not set, all game actions (bet, win, etc.) will be included. */
            action_type?: components["schemas"]["ListGameActionsTypeQuery"] | null;
            /** @description Game ID to filter the game actions by. If not set, all game actions will be included. */
            game_id?: components["schemas"]["GameId"] | null;
        };
        /** @enum {string} */
        ListGameActionsTypeQuery: "bet" | "win";
        ListNotificationsQuery: {
            /** @description The read status of the notifications to filter by. */
            read_status?: components["schemas"]["ReadStatus"] | null;
            /** @description The types of the notifications to filter by. */
            types?: components["schemas"]["NotificationTypeDiscriminants"][] | null;
        };
        ListPaymentFlowsQuery: {
            /** @description The payment type to filter the payment flows by. If not set, all payment types will be included. */
            payment_type?: components["schemas"]["PaymentType"] | null;
            /** @description The wallet ID to filter the payment flows by. If not set, all wallets of the user will be included. */
            wallet_id?: components["schemas"]["WalletId"] | null;
        };
        LoginRequest: {
            /** @description The URL to redirect to after login. If not set a 200 OK response is returned. */
            next?: string | null;
            /** @description The password of the user. */
            password: string;
            /** @description The email address of the user. */
            username: string;
        };
        Maybe_Boolean: boolean | null;
        Maybe_PixKeyTypeDiscriminants: components["schemas"]["PixKeyTypeDiscriminants"] | null;
        Maybe_String: string | null;
        /** Format: int64 */
        NotificationId: number;
        NotificationParams: {
            /** @description The ID of the notification to retrieve. */
            notification_id: components["schemas"]["NotificationId"];
        };
        NotificationResponse: {
            /**
             * Format: date-time
             * @description The time the notification was created.
             */
            created_at: string;
            /** @description The data of the notification. */
            data: components["schemas"]["NotificationType"];
            /** @description The ID of the notification. */
            id: components["schemas"]["NotificationId"];
            /**
             * Format: date-time
             * @description The time the notification was read. If `null` the notification has not been read.
             */
            read_at?: string | null;
        };
        NotificationType: {
            data: {
                flow_id: components["schemas"]["PaymentFlowId"];
                status: components["schemas"]["PaymentStatus"];
            };
            /** @enum {string} */
            type: "payment_status_update";
        } | {
            /** @enum {string} */
            type: "kyc_completed";
        } | {
            data: string;
            /** @enum {string} */
            type: "custom";
        };
        /**
         * @description Auto-generated discriminant enum variants
         * @enum {string}
         */
        NotificationTypeDiscriminants: "payment_status_update" | "kyc_completed" | "custom";
        PaginatorMetadata_for_ListGameActionsQuery: {
            filters?: components["schemas"]["ListGameActionsQuery"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorMetadata_for_ListNotificationsQuery: {
            filters?: components["schemas"]["ListNotificationsQuery"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorMetadata_for_ListPaymentFlowsQuery: {
            filters?: components["schemas"]["ListPaymentFlowsQuery"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorMetadata_for_SearchGameProviderQuery: {
            filters?: components["schemas"]["SearchGameProviderQuery"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorMetadata_for_SearchGameQuery: {
            filters?: components["schemas"]["SearchGameQuery"] | null;
            pagination: components["schemas"]["PaginatorPosition"];
        };
        PaginatorPosition: {
            /**
             * Format: uint
             * @default 20
             */
            limit: number;
            /**
             * Format: uint
             * @default 0
             */
            offset: number;
            /** Format: int64 */
            total_items: number;
        };
        PaginatorResponse_for_GameActionResponse_and_ListGameActionsQuery: {
            data: components["schemas"]["GameActionResponse"][];
            metadata: components["schemas"]["PaginatorMetadata_for_ListGameActionsQuery"];
        };
        PaginatorResponse_for_NotificationResponse_and_ListNotificationsQuery: {
            data: components["schemas"]["NotificationResponse"][];
            metadata: components["schemas"]["PaginatorMetadata_for_ListNotificationsQuery"];
        };
        PaginatorResponse_for_PaymentFlowResponse_and_ListPaymentFlowsQuery: {
            data: components["schemas"]["PaymentFlowResponse"][];
            metadata: components["schemas"]["PaginatorMetadata_for_ListPaymentFlowsQuery"];
        };
        PaginatorResponse_for_SearchGameProviderResponse_and_SearchGameProviderQuery: {
            data: components["schemas"]["SearchGameProviderResponse"][];
            metadata: components["schemas"]["PaginatorMetadata_for_SearchGameProviderQuery"];
        };
        PaginatorResponse_for_SearchGameResponse_and_SearchGameQuery: {
            data: components["schemas"]["SearchGameResponse"][];
            metadata: components["schemas"]["PaginatorMetadata_for_SearchGameQuery"];
        };
        PaginatorSelection: {
            /**
             * Format: uint
             * @default 20
             */
            limit: number;
            /**
             * Format: uint
             * @default 0
             */
            offset: number;
        };
        PatchSignupFlowRequest: {
            [key: string]: unknown;
        };
        PatchUserConsentSettingsRequest: {
            email?: components["schemas"]["Maybe_Boolean"];
            post_mail?: components["schemas"]["Maybe_Boolean"];
            push_notification?: components["schemas"]["Maybe_Boolean"];
            site_notification?: components["schemas"]["Maybe_Boolean"];
            sms?: components["schemas"]["Maybe_Boolean"];
            telephone?: components["schemas"]["Maybe_Boolean"];
        };
        PatchUserPasswordRequest: {
            /** @description The current password of the user. This is required to ensure that the user is the one making the request. */
            current_password: string;
            /** @description The new password of the user. */
            new_password: string;
        };
        PatchUserPaymentSettingsRequest: {
            pix_key_email?: components["schemas"]["Maybe_String"];
            pix_key_evp?: components["schemas"]["Maybe_String"];
            pix_key_phone?: components["schemas"]["Maybe_String"];
            pix_key_type?: components["schemas"]["Maybe_PixKeyTypeDiscriminants"];
        };
        PatchUserSettingsRequest: {
            /** @default {
             *       "email": null,
             *       "post_mail": null,
             *       "push_notification": null,
             *       "site_notification": null,
             *       "sms": null,
             *       "telephone": null
             *     } */
            consents: components["schemas"]["PatchUserConsentSettingsRequest"];
            locale?: components["schemas"]["Maybe_String"];
            /** @default {
             *       "pix_key_email": null,
             *       "pix_key_evp": null,
             *       "pix_key_phone": null,
             *       "pix_key_type": null
             *     } */
            payment: components["schemas"]["PatchUserPaymentSettingsRequest"];
            time_zone?: components["schemas"]["Maybe_String"];
        };
        /** Format: int64 */
        PaymentFlowId: number;
        PaymentFlowResponse: {
            /** @description The amount of the payment flow. */
            amount: components["schemas"]["SystemAmount"];
            /**
             * Format: date-time
             * @description The time the payment flow was created.
             */
            created_at: string;
            /** @description The currency of the payment flow. */
            currency: components["schemas"]["SystemCurrency"];
            /** @description The ID of the payment flow. */
            id: components["schemas"]["PaymentFlowId"];
            /** @description The identifier of the payment flow. This is a unique identifier that can be used to reference the payment flow. */
            identifier: string;
            /** @description The payment method ID the payment flow is associated with. */
            payment_method_id: components["schemas"]["PaymentMethodId"];
            /** @description The type of the payment flow. */
            payment_type: components["schemas"]["PaymentType"];
            /** @description The last status of the payment flow. If no status is set, the payment has been initialized but not yet processed by the system in any way. */
            status?: components["schemas"]["PaymentStatus"] | null;
            /**
             * Format: date-time
             * @description The time the payment flo
             */
            status_updated_at?: string | null;
            /** @description The wallet ID the payment flow is associated with. */
            wallet_id: components["schemas"]["WalletId"];
        };
        /** @enum {string} */
        PaymentLimitBound: "min" | "max";
        PaymentLimitsQuery: {
            /** @description The currency to get the payment limits for. */
            currency: components["schemas"]["SystemCurrency"];
            /** @description The payment method to get the payment limits for. */
            payment_method_id: components["schemas"]["PaymentMethodId"];
        };
        PaymentLimitsResponse: {
            /** @description The number of seconds a user has to wait between deposits. */
            deposit_cooldown?: components["schemas"]["DurationSeconds"] | null;
            /** @description The maximum deposit amount. This already accounts for first time deposit limits. */
            deposit_max?: components["schemas"]["SystemAmount"] | null;
            /** @description The minimum deposit amount. This already accounts for first time deposit limits. */
            deposit_min?: components["schemas"]["SystemAmount"] | null;
            /** @description Timeframe limits enforce that a user does not exceed payment limits over a certain timeframe. This can be used to enforce daily, weekly, monthly limits, etc. */
            timeframe_limits: components["schemas"]["PaymentLimitsTimeframeResponse"][];
            /** @description The number of seconds a user has to wait between withdrawals. */
            withdrawal_cooldown?: components["schemas"]["DurationSeconds"] | null;
            /** @description The maximum withdrawal amount. This already accounts for first time withdrawal limits. */
            withdrawal_max?: components["schemas"]["SystemAmount"] | null;
            /** @description The minimum withdrawal amount. This already accounts for first time withdrawal limits. */
            withdrawal_min?: components["schemas"]["SystemAmount"] | null;
        };
        PaymentLimitsTimeframeResponse: {
            /**
             * Format: int64
             * @description The number of days the timeframe limit applies to.
             */
            days: number;
            /** @description The deposit limit for the timeframe. */
            deposit?: components["schemas"]["SystemAmount"] | null;
            /** @description The withdrawal limit for the timeframe. */
            withdrawal?: components["schemas"]["SystemAmount"] | null;
        };
        /** Format: int64 */
        PaymentMethodId: number;
        /** @enum {string} */
        PaymentMethodIdentifier: "pix";
        PaymentMethodResponse: {
            /** @description A non-internationalized description of the payment method. This should not be used for display purposes, as it may not be localized. Handle i18n via custom translation through the identifier attribute. */
            description?: string | null;
            /** @description The ID of the payment method. */
            id: components["schemas"]["PaymentMethodId"];
            /** @description The identifier of the payment method. This is a unique identifier that can be used to reference the payment method. */
            identifier: components["schemas"]["PaymentMethodIdentifier"];
            /** @description The name of the payment method. Do not use this for identification purposes, as names may not be unique as there may be multiple payment methods with the same name but different countries or currencies. */
            name: string;
            /** @description The type of the payment method, which can be used to determine how the payment method can be used and how it may be displayed to the user. */
            payment_method_type: components["schemas"]["PaymentMethodType"];
        };
        PaymentMethodType: "card" | "bank_transfer" | "direct_debit" | "bank_redirect" | "e_wallet" | "mobile_payment" | "buy_now_pay_later" | "cash_payment" | "cryptocurrency" | "carrier_billing" | "cheque" | "invoice" | "loyalty_points" | "voucher" | "qr_code_payment" | "nfc_payment" | "money_order" | "regional";
        /** @enum {string} */
        PaymentStatus: "pending" | "waiting_for_approval" | "approved" | "processing" | "completed" | "failed" | "cancelled" | "rejected" | "refunded";
        PaymentTransactionRequest: {
            /** @description The amount of the payment transaction. */
            amount: components["schemas"]["SystemAmount"];
            /** @description The currency of the payment transaction. */
            currency: components["schemas"]["SystemCurrency"];
            /** @description The payment method ID to use for the payment transaction. */
            payment_method_id: components["schemas"]["PaymentMethodId"];
        };
        /** @enum {string} */
        PaymentType: "deposit" | "withdrawal";
        /**
         * @description Auto-generated discriminant enum variants
         * @enum {string}
         */
        PixKeyTypeDiscriminants: "CPF" | "EMAIL" | "PHONE" | "EVP";
        RateGameRequest: {
            /** @description The rating to set for the game. If `null` the rating for the current user is removed. */
            rating?: components["schemas"]["GameRating"] | null;
        };
        /** @enum {string} */
        ReadStatus: "read" | "unread";
        RtcEventPayload: {
            /** @enum {string} */
            event: "notification";
            payload: components["schemas"]["NotificationType"];
        } | {
            /** @enum {string} */
            event: "ticker";
            payload: components["schemas"]["TickerType"];
        };
        SearchGameProviderQuery: {
            /** @description An organic search query to find game providers by. Searched fields include but are not limited to: name, description, slug... */
            query?: string | null;
        };
        /** @description The response to a game provider search request. It only contains a limited set of information about the provider. If more information is needed, the provider ID can be used to fetch the full provider details via the "get provider" endpoint. */
        SearchGameProviderResponse: {
            /** @description The ID of the game provider. */
            id: components["schemas"]["GameProviderId"];
            image_url: string;
            /** @description The name of the game provider. Do not use this in URLs, as it may contain special characters. */
            name: string;
            /**
             * Format: double
             * @description The search score of the game provider.
             */
            score?: number | null;
            /** @description The slug of the game provider. This may be used in URLs. */
            slug: string;
        };
        SearchGameQuery: {
            /** @description The category identifier to filter games by. If set, only games in this category are returned. Note: this is not the category ID, but the identifier. */
            category?: string | null;
            /**
             * Format: int64
             * @description The provider to filter games by. If set, only games by this provider are returned.
             */
            provider_id?: number | null;
            /** @description An organic search query to find games by. Searched fields include but are not limited to: name, description, provider name... */
            query?: string | null;
        };
        /** @description The response to a game search request. It only contains a limited set of information about the game. If more information is needed, the game ID can be used to fetch the full game details via the "get game" endpoint. */
        SearchGameResponse: {
            /** @description The ID of the game. */
            id: components["schemas"]["GameId"];
            /** @description The URL to the image of the game. */
            image_url: string;
            /** @description The name of the game. Do not use this in URLs, as it may contain special characters. */
            name: string;
            /** @description The provider of the game. */
            provider: components["schemas"]["SearchGameProviderResponse"];
            /**
             * Format: double
             * @description The search score of the game.
             */
            score?: number | null;
            /** @description The slug of the game. This may be used in URLs. */
            slug: string;
        };
        SelectWalletRequest: {
            /** @description The ID of the wallet to select. */
            currency: components["schemas"]["SystemCurrency"];
        };
        /** @description Represents various errors that can occur during server operations.
         *
         *     This enum covers a wide range of error scenarios, from wallet-related issues to payment processing problems, user authentication errors, and more. */
        ServerError: {
            /** @enum {string} */
            code: "WALLET_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "WALLET_PENDING_FLOW";
            metadata: components["schemas"]["PaymentType"];
        } | {
            /** @enum {string} */
            code: "WALLET_MISSING_PAYMENT_METHOD";
        } | {
            /** @enum {string} */
            code: "WALLET_INSUFFICIENT_FUNDS";
        } | {
            /** @enum {string} */
            code: "WALLET_MISSING_DEPOSIT";
        } | {
            /** @enum {string} */
            code: "WALLET_INSUFFICIENT_WAGERS";
        } | {
            /** @enum {string} */
            code: "WALLET_PAYMENT_COOLDOWN";
            metadata: {
                /**
                 * Format: int64
                 * @description Minutes left until the user is allowed to make another payment
                 */
                minutes_left: number;
            };
        } | {
            /** @enum {string} */
            code: "PAYMENT_METHOD_NOT_ALLOWED";
        } | {
            /** @enum {string} */
            code: "PAYMENT_AMOUNT_OUTSIDE_LIMITS";
            metadata: {
                /** @description The bound that is violated */
                bound: components["schemas"]["PaymentLimitBound"];
                /** @description The maximum allowed payment amount */
                max?: string | null;
                /** @description The minimum allowed payment amount */
                min?: string | null;
            };
        } | {
            /** @enum {string} */
            code: "PAYMENT_AMOUNT_EXCEEDS_TIMEFRAME_LIMITS";
            metadata: {
                /**
                 * Format: int64
                 * @description The number of past days the limit is enforced for
                 */
                days: number;
                /** @description The monetary limit that is not allowed to be exceeded */
                limit: string;
            };
        } | {
            /** @enum {string} */
            code: "PAYMENT_AMOUNT_OUT_OF_BOUNDS";
        } | {
            /** @enum {string} */
            code: "PAYMENT_FLOW_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "PAYMENT_FLOW_INVALID_STATE";
        } | {
            /** @enum {string} */
            code: "PAYMENT_FLOW_NOT_AWAITING_APPROVAL";
        } | {
            /** @enum {string} */
            code: "PAYMENT_PROVIDER_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "NO_PAYMENT_PROVIDER_AVAILABLE";
        } | {
            /** @enum {string} */
            code: "PAYMENT_METHOD_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "KYC_PROVIDER_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "SEARCH_INDEX_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "USER_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "USER_MISSING_PAYMENT_METHOD_ACCOUNT_TYPE_IDENTIFIER";
            metadata: {
                account_type: string;
                payment_method: components["schemas"]["PaymentMethodIdentifier"];
            };
        } | {
            /** @enum {string} */
            code: "USER_MISSING_DOCUMENT";
        } | {
            /** @enum {string} */
            code: "USER_INVALID_DOCUMENT";
        } | {
            /** @enum {string} */
            code: "USER_ADDRESS_MISSING";
        } | {
            /** @enum {string} */
            code: "USER_KYC_REQUIRED";
        } | {
            /** @enum {string} */
            code: "USER_EXCLUDED";
        } | {
            /** @enum {string} */
            code: "USER_BLOCKED";
        } | {
            /** @enum {string} */
            code: "JURISDICTION_NOT_SUPPORTED_NO_ALTERNATIVE_SITE";
            metadata: {
                /** @description The violating jurisdiction. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "JURISDICTION_NOT_SUPPORTED_ALTERNATIVE_SITE";
            metadata: {
                /** @description Alternative site that the user may be redirected to */
                alternative_site: components["schemas"]["AlternativeSite"];
                /** @description The violating jurisdiction. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "USER_ACCOUNT_JURISDICTION_MISMATCH";
            metadata: {
                /** @description The violating jurisdiction. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "JURISDICTION_SUPPORTED_BUT_NOT_ENABLED";
            metadata: {
                /** @description The jurisdiction that is supported but not enabled. */
                jurisdiction: components["schemas"]["SystemCountry"];
            };
        } | {
            /** @enum {string} */
            code: "HOST_NOT_SUPPORTED";
        } | {
            /** @enum {string} */
            code: "GAME_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_PROVIDER_NOT_REACHABLE";
        } | {
            /** @enum {string} */
            code: "GAME_PROVIDER_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_PROVIDER_MAPPING_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_NOT_SUPPORTED";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_MISSING";
        } | {
            /** @enum {string} */
            code: "GAME_AGGREGATOR_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "GAME_URL_INVALID";
        } | {
            /** @enum {string} */
            code: "SIGNUP_FLOW_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "SIGNUP_INVALID_PROFILE";
        } | {
            /** @enum {string} */
            code: "EXCHANGE_RATE_NOT_FOUND";
            metadata: {
                from: components["schemas"]["SystemCurrency"];
                to: components["schemas"]["SystemCurrency"];
            };
        } | {
            /** @enum {string} */
            code: "INVALID_SIGNATURE";
        } | {
            /** @enum {string} */
            code: "INVALID_ENCODING";
        } | {
            /** @enum {string} */
            code: "MISSING_SEC_WEB_SOCKET_PROTOCOL";
        } | {
            /** @enum {string} */
            code: "INVALID_USER_GEOLOCATION";
        } | {
            /** @enum {string} */
            code: "INVALID_BOT_HEADER";
        } | {
            /** @enum {string} */
            code: "LEASE_NOT_FOUND";
        } | {
            /** @enum {string} */
            code: "VALIDATION";
            metadata: components["schemas"]["SystemValidationErrors"];
        } | {
            /** @enum {string} */
            code: "UNAUTHORIZED";
        } | {
            /** @enum {string} */
            code: "FORBIDDEN";
        } | {
            /** @enum {string} */
            code: "INTERNAL";
            metadata: components["schemas"]["InternalError"];
        };
        SignupFlowParams: {
            /** @description The ID of the signup flow to retrieve. */
            flow_id: string;
        };
        SignupFlowResponse: {
            /**
             * Format: date-time
             * @description The time the signup flow was created.
             */
            created_at: string;
            /** @description The fields of the signup flow. */
            fields: {
                [key: string]: unknown;
            };
            /** @description The ID of the signup flow. */
            id: string;
            /** @description The jurisdiction of the signup flow. This field can not be changed once set. The user will be created in this jurisdiction and thus is subject to the laws of this jurisdiction. Changing a user jurisdiction after signup is not easily possible without additional verification, information and setup. */
            jurisdiction: components["schemas"]["SystemCountry"];
        };
        SiteResponse: {
            /** @description The base URL of the site. This may be used for redirects, links, etc. */
            base_url: components["schemas"]["SystemUrl"];
            /** @description The name of the site. */
            name: string;
            /** @description Whether the site is servable by the current instance. If `false` the site is not servable but is accessible by a different casino instance of the owning company. */
            servable: boolean;
        };
        /** Format: float */
        SystemAmount: number;
        /**
         * @description A country represented by its ISO 3166-1 alpha-2 code.
         * @enum {unknown}
         */
        SystemCountry: "AF" | "AX" | "AL" | "DZ" | "AS" | "AD" | "AO" | "AI" | "AQ" | "AG" | "AR" | "AM" | "AW" | "AU" | "AT" | "AZ" | "BS" | "BH" | "BD" | "BB" | "BY" | "BE" | "BZ" | "BJ" | "BM" | "BT" | "BO" | "BQ" | "BA" | "BW" | "BV" | "BR" | "IO" | "BN" | "BG" | "BF" | "BI" | "CV" | "KH" | "CM" | "CA" | "KY" | "CF" | "TD" | "CL" | "CN" | "CX" | "CC" | "CO" | "KM" | "CG" | "CD" | "CK" | "CR" | "CI" | "HR" | "CU" | "CW" | "CY" | "CZ" | "DK" | "DJ" | "DM" | "DO" | "EC" | "EG" | "SV" | "GQ" | "ER" | "EE" | "SZ" | "ET" | "FK" | "FO" | "FJ" | "FI" | "FR" | "GF" | "PF" | "TF" | "GA" | "GM" | "GE" | "DE" | "GH" | "GI" | "GR" | "GL" | "GD" | "GP" | "GU" | "GT" | "GG" | "GN" | "GW" | "GY" | "HT" | "HM" | "VA" | "HN" | "HK" | "HU" | "IS" | "IN" | "ID" | "IR" | "IQ" | "IE" | "IM" | "IL" | "IT" | "JM" | "JP" | "JE" | "JO" | "KZ" | "KE" | "KI" | "KP" | "KR" | "KW" | "KG" | "LA" | "LV" | "LB" | "LS" | "LR" | "LY" | "LI" | "LT" | "LU" | "MO" | "MG" | "MW" | "MY" | "MV" | "ML" | "MT" | "MH" | "MQ" | "MR" | "MU" | "YT" | "MX" | "FM" | "MD" | "MC" | "MN" | "ME" | "MS" | "MA" | "MZ" | "MM" | "NA" | "NR" | "NP" | "NL" | "NC" | "NZ" | "NI" | "NE" | "NG" | "NU" | "NF" | "MK" | "MP" | "NO" | "OM" | "PK" | "PW" | "PS" | "PA" | "PG" | "PY" | "PE" | "PH" | "PN" | "PL" | "PT" | "PR" | "QA" | "RE" | "RO" | "RU" | "RW" | "BL" | "SH" | "KN" | "LC" | "MF" | "PM" | "VC" | "WS" | "SM" | "ST" | "SA" | "SN" | "RS" | "SC" | "SL" | "SG" | "SX" | "SK" | "SI" | "SB" | "SO" | "ZA" | "GS" | "SS" | "ES" | "LK" | "SD" | "SR" | "SJ" | "SE" | "CH" | "SY" | "TW" | "TJ" | "TZ" | "TH" | "TL" | "TG" | "TK" | "TO" | "TT" | "TN" | "TR" | "TM" | "TC" | "TV" | "UG" | "UA" | "AE" | "GB" | "US" | "UM" | "UY" | "UZ" | "VU" | "VE" | "VN" | "VG" | "VI" | "WF" | "EH" | "YE" | "ZM" | "ZW";
        /** @description ISO 4217 3-letter currency code or 3/4-letter crypto currency code */
        SystemCurrency: unknown;
        /** @enum {string} */
        SystemDevice: "mobile" | "desktop";
        /** @enum {string} */
        SystemGender: "male" | "female" | "other";
        SystemPhoneNumber: {
            carrier?: string;
            code: {
                /** @enum {string} */
                source: "plus" | "idd" | "number" | "default";
                value: number;
            };
            extension?: string;
            national: {
                value: number;
            };
        };
        /** Format: uri */
        SystemUrl: string;
        SystemValidationError: {
            code: string;
            message?: string | null;
            params: {
                [key: string]: unknown;
            };
        };
        SystemValidationErrors: {
            [key: string]: components["schemas"]["SystemValidationErrorsKind"];
        };
        SystemValidationErrorsKind: components["schemas"]["SystemValidationErrors"] | {
            [key: string]: components["schemas"]["SystemValidationErrors"];
        } | components["schemas"]["SystemValidationError"][];
        TickerGame: {
            /** @description The ID of the game. */
            id: components["schemas"]["GameId"];
            /** @description The URL to the image of the game. */
            image_url: string;
            /** @description The name of the game. Do not use this in URLs, as it may contain special characters. */
            name: string;
            /** @description The slug of the game. This may be used in URLs. */
            slug: string;
        };
        TickerType: {
            data: {
                amount: components["schemas"]["SystemAmount"];
                currency: components["schemas"]["SystemCurrency"];
                game: components["schemas"]["TickerGame"];
                user_nickname: string;
            };
            /** @enum {string} */
            type: "winning_now";
        };
        UserBalanceResponse: {
            /** @description The balance of the wallet. */
            balance: components["schemas"]["SystemAmount"];
            /** @description The currency of the wallet. */
            currency: components["schemas"]["SystemCurrency"];
            /** @description The ID of the wallet that the balance is for. */
            wallet_id: components["schemas"]["WalletId"];
        };
        /** Format: int64 */
        UserId: number;
        UserResponse: {
            /**
             * Format: date
             * @description The birthdate of the user.
             */
            birthdate: string;
            /** @description The email of the user. */
            email: string;
            /** @description The family name of the user. We have methods of deriving the family name should we only get a name from e.g. a KYC provider, but they may not be 100% reliable and thus the existence of this field can not be guaranteed. */
            family_name?: string | null;
            /** @description The gender of the user. */
            gender?: components["schemas"]["SystemGender"] | null;
            /** @description The ID of the user. */
            id: components["schemas"]["UserId"];
            /** @description The jurisdiction of the user. This field can not be easily changed once set. */
            jurisdiction: components["schemas"]["SystemCountry"];
            /** @description The language of the user in ISO 639-1 format. */
            locale: string;
            /** @description The name of the user. */
            name: string;
            /** @description The phone number of the user. */
            phone: components["schemas"]["SystemPhoneNumber"];
            /** @description The time zone of the user in IANA time zone format. */
            time_zone: string;
        };
        /** Format: int64 */
        WalletId: number;
        /** @enum {string} */
        WebSocketChannel: "user" | "newest_wins";
        WebsocketLeaseRequest: {
            /** @description The channel to subscribe to. */
            channel: components["schemas"]["WebSocketChannel"];
        };
        WhoamiResponse: {
            /** @description The email address of the currently authenticated user. */
            email: string;
            /** @description The user ID of the currently authenticated user. */
            id: components["schemas"]["UserId"];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
